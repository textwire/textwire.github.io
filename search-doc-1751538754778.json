{"searchDocs":[{"title":"v2.1.0 Release Notes","type":0,"sectionRef":"#","url":"/blog/2024/10/24/textwire-v2.1.0-release-notes","content":"","keywords":"","version":null},{"title":"15 New Built-in Functions‚Äã","type":1,"pageTitle":"v2.1.0 Release Notes","url":"/blog/2024/10/24/textwire-v2.1.0-release-notes#15-new-built-in-functions","content":" ","version":null,"tagName":"h2"},{"title":"4 New array functions‚Äã","type":1,"pageTitle":"v2.1.0 Release Notes","url":"/blog/2024/10/24/textwire-v2.1.0-release-notes#4-new-array-functions","content":" Textwire is very young but it's growing. I'm happy to introduce 3 new built-in functions for array literals. You can read more about them in the array functions documentation. Here is the short overview of them:  rand() - Returns a random element from an arrayreverse() - Reverses the elements of an array and returns a new arrayslice(start: int, end?: int) - Returns a portion of an arrayshuffle() - Shuffles the elements of an array and returns a new array  ","version":null,"tagName":"h3"},{"title":"2 New integer functions‚Äã","type":1,"pageTitle":"v2.1.0 Release Notes","url":"/blog/2024/10/24/textwire-v2.1.0-release-notes#2-new-integer-functions","content":" Read more about them in the integer functions documentation.  abs(): int - Returns the absolute value of an integer. If the integer is negative, it will return the positive value of itstr(): str - Converts an integer to a string and returns it  ","version":null,"tagName":"h3"},{"title":"5 New float functions‚Äã","type":1,"pageTitle":"v2.1.0 Release Notes","url":"/blog/2024/10/24/textwire-v2.1.0-release-notes#5-new-float-functions","content":" Read more about them in the float functions documentation.  abs(): float - Returns the absolute value of a float. If the float is negative, it will return the positive value of itceil(): int - Returns the rounded up value of a float to the nearest integerfloor(): int - Returns the rounded down value of a float to the nearest integerround(): int - Rounds a float to the nearest integer. 1.5 -&gt; 2, 1.4 -&gt; 1, 1.6 -&gt; 2str(): str - Returns converted float to a string  ","version":null,"tagName":"h3"},{"title":"3 New string functions‚Äã","type":1,"pageTitle":"v2.1.0 Release Notes","url":"/blog/2024/10/24/textwire-v2.1.0-release-notes#3-new-string-functions","content":" Read more about them in the string functions documentation.  capitalize(): bool - Capitalizes the first letter of a stringreverse(): bool - Reverses the characters of a stringcontains(substr: str): bool - Returns true if a string contains a substring, otherwise false  ","version":null,"tagName":"h3"},{"title":"1 New boolean function‚Äã","type":1,"pageTitle":"v2.1.0 Release Notes","url":"/blog/2024/10/24/textwire-v2.1.0-release-notes#1-new-boolean-function","content":" Read more about it in the boolean functions documentation.  binary(): int - Returns an integer 1 if the receiver is true, 0 otherwise  ","version":null,"tagName":"h3"},{"title":"Improvements‚Äã","type":1,"pageTitle":"v2.1.0 Release Notes","url":"/blog/2024/10/24/textwire-v2.1.0-release-notes#improvements","content":" Regarding improvements, I placed a strong emphasis on proper error handling. I cannot overstate the importance of having effective error handling in place when things go wrong. Receiving clear and detailed error messages is crucial for success. Here are the enhancements introduced in version v2.1.0:  üêõ Fixed Bug with Prefix Expression Precedence: Resolved an issue where prefix expressions like {{ -1.abs() }} were not being processed correctly. Previously, the parser evaluated the expression as {{ (-(1.abs())) }}, resulting in an incorrect output of -1. Now, the parser correctly handles the precedence, evaluating it as {{ ((-1).abs()) }}.üßë‚Äçüíª Enhanced Error Handling for Built-in Functions: Improved error messages when an incorrect argument type is passed to a built-in function. Users will now receive clear error messages indicating the type mismatch.üßë‚Äçüíª Enhanced Error Handling for Custom Functions: If a function is called on a type where it doesn‚Äôt exist, Textwire now provides a detailed error message specifying that the function is undefined for that type. For example, an error message might read: [Textwire ERROR in /var/www/html/templates/home.tw.html:3]: function 'some' doesn't exist for type 'STRING'.üßë‚Äçüíª Enhanced Error Handling for Division by Zero: Improved error messages for division-by-zero cases, replacing previous vague messages with more meaningful ones.üßë‚Äçüíª New error page while rendering a template. Instead of black screen we now get a simple error page with Sorry! We‚Äôre having some trouble right now. Please check back shortly. You can find more information here  New error page:‚Äã    ","version":null,"tagName":"h2"},{"title":"Other changes‚Äã","type":1,"pageTitle":"v2.1.0 Release Notes","url":"/blog/2024/10/24/textwire-v2.1.0-release-notes#other-changes","content":" Some very small changes were made to the Textwire that don't effect any functionality. Here are they:  üìù Remove CONTRIBUTING.md file that was added in v2.0.0. It doesn't have any important information, it's better to make a better one in the future  ","version":null,"tagName":"h2"},{"title":"Conclusion‚Äã","type":1,"pageTitle":"v2.1.0 Release Notes","url":"/blog/2024/10/24/textwire-v2.1.0-release-notes#conclusion","content":" Version v2.1.0 of Textwire brings a host of new built-in functions, improved error handling, and other enhancements. I hope you enjoy using Textwire as much as I enjoy developing it. If you have any questions or feedback, please don't hesitate to reach out to me. I'm always happy to help. Thank you for your continued support and feedback. Stay tuned for more updates and improvements in the future. Happy coding! üöÄ  ","version":null,"tagName":"h2"},{"title":"What's next?‚Äã","type":1,"pageTitle":"v2.1.0 Release Notes","url":"/blog/2024/10/24/textwire-v2.1.0-release-notes#whats-next","content":" In the next version, I'll focus on further improvements to the language, including new built-in functions, better error handling, more tests, and the ability to define a custom error page for templates. Stay tuned for more updates and improvements in the future. Happy coding! üöÄ ","version":null,"tagName":"h2"},{"title":"Introducing Textwire: A Domain-Specific Language for Go","type":0,"sectionRef":"#","url":"/blog/2024/10/20/introducing-textwire-a-domain-specific-language-for-go","content":"","keywords":"","version":null},{"title":"What's Textwire?‚Äã","type":1,"pageTitle":"Introducing Textwire: A Domain-Specific Language for Go","url":"/blog/2024/10/20/introducing-textwire-a-domain-specific-language-for-go#whats-textwire","content":" Textwire is a domain-specific language (DSL) for Go that offers a simple, flexible, and declarative syntax for the front end. It enables you to handle business logic on the backend and pass the processed data to Textwire templates.  Here‚Äôs a quick example of what a basic Textwire template looks like:  index.tw &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;My blog&lt;/title&gt; &lt;/head&gt; &lt;body&gt; @if(age &lt; 18) &lt;p&gt;You are under 18 years old&lt;/p&gt; @end &lt;/body&gt; &lt;/html&gt;   As shown, the syntax is clean and intuitive. You can also incorporate else-if conditions, loops, components, and more, making Textwire a powerful tool for template management in Go.  ","version":null,"tagName":"h2"},{"title":"Why Textwire over other template engines?‚Äã","type":1,"pageTitle":"Introducing Textwire: A Domain-Specific Language for Go","url":"/blog/2024/10/20/introducing-textwire-a-domain-specific-language-for-go#why-textwire-over-other-template-engines","content":" Textwire is more than just another template engine for Go‚Äîit allows you to evaluate strings or files containing Textwire code. This means you can seamlessly integrate logic into your email templates, markdown files, or any other text-based content.  Additionally, Textwire comes with a VSCode extension that offers syntax highlighting and icons for Textwire files, making template development even more straightforward. Plugin for Neovim is coming soon.    Here are some of the key benefits of using Textwire:  Error handling. Textwire provides detailed error messages with line numbers and file names, making it easier to debug your templatesPerformance. Textwire is fast and has a low memory footprint, making it load pages quickly. The parsing is done at application startup, so there is no overhead during runtimeFlexibility. Textwire allows you to define custom functions and components, giving you the flexibility to create complex templates with easeSecurity. Textwire is designed to be secure by default, preventing code injection attacks when printing user-generated contentSupport. Textwire is constantly being improved and updated. Which means you can rely on it for your projectsGood documentation. Textwire has a comprehensive documentation that covers all the features and provides examples to help you get started    ","version":null,"tagName":"h2"},{"title":"Resources‚Äã","type":1,"pageTitle":"Introducing Textwire: A Domain-Specific Language for Go","url":"/blog/2024/10/20/introducing-textwire-a-domain-specific-language-for-go#resources","content":" For all the details on how to get started with Textwire, check out the official documentation. You can also find the source code on GitHub. If you have any requests or suggestions that will help improve Textwire, feel free to open an issue or submit a pull request. ","version":null,"tagName":"h2"},{"title":"Frequently Asked Questions (FAQ)","type":0,"sectionRef":"#","url":"/docs/v2/faq/","content":"Frequently Asked Questions (FAQ) Welcome to our FAQ page, where we address the most common questions and concerns about using Textwire. Whether you‚Äôre new to Textwire or a seasoned user, FAQ is designed to provide quick and helpful answers to your most pressing queries. Here, you‚Äôll find explanations, solutions to common problems, and best practices to make the most of your experience. If you don‚Äôt find the answer you‚Äôre looking for, feel free to reach out to us by creating an issue on GitHub and we‚Äôll be happy to help and update FAQ with your question to help others. üìÑÔ∏è Questions Find answers to frequently asked questions about Textwire, including its purpose, usage, and how it differs from templating engines üìÑÔ∏è Usage Learn how to use Textwire directives and more in your Textwire code","keywords":"","version":null},{"title":"Questions","type":0,"sectionRef":"#","url":"/docs/v2/faq/questions","content":"","keywords":"","version":null},{"title":"What exactly is Textwire?‚Äã","type":1,"pageTitle":"Questions","url":"/docs/v2/faq/questions#what-exactly-is-textwire","content":" Textwire is a programming language designed to be used with Go programs. Since Go doesn't have a simple and easy to use template language, Textwire was created to fill that gap. It is a simple and easy to use language that can be used with any text files.  ","version":null,"tagName":"h2"},{"title":"How Textwire parses text files?‚Äã","type":1,"pageTitle":"Questions","url":"/docs/v2/faq/questions#how-textwire-parses-text-files","content":" Textwire has it's own lexing and parsing engine that is used to parse text files. It reads the text file line by line and converts it into a tree of nodes. Each node represents a part of the text file and can be used to generate the final output.  All the non-Textwire specific parts of the text file are not parsed as HTML, XML or any other format. They are treated as plain text and are not modified in any way. Even whitespace in your text is preserved in the final output. The only parts that are parsed are the Textwire specific parts, like directives and expressions like:  {{ &quot;Hello, World!&quot;.upper() }}   That's why Textwire is fast and efficient, as it only parses the parts that are necessary and leaves the rest as is.  ","version":null,"tagName":"h2"},{"title":"Is Textwire a templating engine?‚Äã","type":1,"pageTitle":"Questions","url":"/docs/v2/faq/questions#is-textwire-a-templating-engine","content":" Textwire is not exactly a templating engine. It is a Domain-specific language (DTO) written in Go. It is designed to be used with Go programs to provide elegant and easy to use syntax for working with front-end. It's a good alternative to other templating engines for Go since it's performant and optimized.  ","version":null,"tagName":"h2"},{"title":"Why it's best to prevent visitors of your site from seeing the result of the function output when an error occurs?‚Äã","type":1,"pageTitle":"Questions","url":"/docs/v2/faq/questions#why-its-best-to-prevent-visitors-of-your-site-from-seeing-the-result-of-the-function-output-when-an-error-occurs","content":" When an error occurs in your function, the output may be incorrect or misleading. Displaying this faulty output to users can result in confusing information, broken layouts, or even unintentionally exposing sensitive data.  For example, a function might return partial or incorrect data due to an error in the logic or wrong inputs. If this faulty output is displayed to your site‚Äôs visitors, it could negatively impact the user experience by showing inaccurate information or broken page elements.  Moreover, displaying incorrect output can also pose security risks, as it might reveal unintended details about the internal workings of your system, or expose raw data that wasn‚Äôt meant to be shown. By hiding incorrect output when an error occurs, you ensure that visitors only see validated, correct content, maintaining both the integrity of your site‚Äôs data and the trustworthiness of your user experience.  ","version":null,"tagName":"h2"},{"title":"What is the difference between directives and statements in Textwire?‚Äã","type":1,"pageTitle":"Questions","url":"/docs/v2/faq/questions#what-is-the-difference-between-directives-and-statements-in-textwire","content":" Directives and statements are the core of Textwire language. They are used to define the structure and behavior of your text files. However, there are some key differences between them:  All directives are statements, but not all statements are directivesDirectives start with the @ symbol, while statements is a general term for parts of code that perform and action and do not return a value  note You can read about statements in the Statements section of the documentation.  For example, {{ x = 5 }} is a statement that assigns the value 5 to the variable x. On the other hand, @use('~main') is a directive and a statement at the same time, as it includes the layout main in the current file and doesn't return a value. ","version":null,"tagName":"h2"},{"title":"Built-in Functions","type":0,"sectionRef":"#","url":"/docs/v2/functions/","content":"","keywords":"","version":null},{"title":"Built-in functions usage‚Äã","type":1,"pageTitle":"Built-in Functions","url":"/docs/v2/functions/#built-in-functions-usage","content":" Each function is attached to a specific data type. For example, the len function is used to get the length of an array, and the trim function is used to remove characters from both sides of the string. You can call a function on a value by using the dot operator (.) followed by the function name.  {{ &quot;Textwire&quot;.len() }} &lt;!-- output: 8 --&gt;   You can also chain multiple functions together to perform complex operations.  {{ &quot; Textwire &quot;.trim().len() }} &lt;!-- output: 8 --&gt;   Error handling Learn about error handling in Textwire when you call a function that doesn't exist, or when you pass incorrect arguments  ","version":null,"tagName":"h2"},{"title":"Unicode friendly‚Äã","type":1,"pageTitle":"Built-in Functions","url":"/docs/v2/functions/#unicode-friendly","content":" Since I speak 4 languages, Russian, English, Chinese, and Ukrainian, I understand the importance of Unicode support. So, I'm trying to make Textwire as Unicode friendly as possible to setisfy the needs of people from different countries.  All the built-in functions in Textwire are Unicode friendly, which means they can handle Unicode characters and strings without any issues. You can use these functions to manipulate strings in any language. For example:  {{ &quot;ÊàëÂñúÊ¨¢‰∏≠ÂõΩ&quot;.len() }} &lt;!-- output: 5 --&gt;   Or:  {{ &quot;–ø—Ä–∏–≤–µ—Ç&quot;.at(2) }} &lt;!-- output: –∏ --&gt;   ","version":null,"tagName":"h2"},{"title":"Suggest a new function‚Äã","type":1,"pageTitle":"Built-in Functions","url":"/docs/v2/functions/#suggest-a-new-function","content":" New functions are added in new version of Textwire when there is a need for them. You can follow the updates in our Release Notes on GitHub.  If you have a suggestion for a new functions that might benefit everybody using Textwire, please open an issue on GitHub or email me at serhiicho@protonmail.com and I will consider adding it in the next version. Just quick suggestion in a single paragraph is enough. ","version":null,"tagName":"h2"},{"title":"Textwire Usage","type":0,"sectionRef":"#","url":"/docs/v2/faq/usage","content":"","keywords":"","version":null},{"title":"How do I use Textwire directives that start with @ symbol?‚Äã","type":1,"pageTitle":"Textwire Usage","url":"/docs/v2/faq/usage#how-do-i-use-textwire-directives-that-start-with--symbol","content":" Textwire has several directives that you can use anywhere directly in your text files except for {{ }} curly braces. Here is the example of @if directive:  &lt;div&gt; @if(isFast) &lt;b&gt;Can run&lt;/b&gt; @else &lt;b&gt;Can't run&lt;/b&gt; @end &lt;/div&gt;  ","version":null,"tagName":"h2"},{"title":"v2.4.0 Release Notes","type":0,"sectionRef":"#","url":"/blog/2025/01/10/textwire-v2.4.0","content":"","keywords":"","version":null},{"title":"Component Path Alias‚Äã","type":1,"pageTitle":"v2.4.0 Release Notes","url":"/blog/2025/01/10/textwire-v2.4.0#component-path-alias","content":" Component Path Alias is a small but useful feature that is useful for people who will keep their components in the components directory. The ~ alias can be used to reference components in the components directory.  Consider this example of calling a components/post-card component before the version v2.4.0:  &lt;div class=&quot;posts&quot;&gt; @each(post in posts) @component(&quot;components/post-card&quot;, { post }) @end &lt;/div&gt;   Now you can repleace the components/ part with ~ alias like so:  &lt;div class=&quot;posts&quot;&gt; @each(post in posts) @component(&quot;~post-card&quot;, { post }) @end &lt;/div&gt;   The ~ alias will be replaced with components/ behind the scenes.  ","version":null,"tagName":"h2"},{"title":"New trimRight and trimLeft Functions‚Äã","type":1,"pageTitle":"v2.4.0 Release Notes","url":"/blog/2025/01/10/textwire-v2.4.0#new-trimright-and-trimleft-functions","content":" A couple of people suggested to add trimRight and trimLeft functions and now they are available in the v2.4.0 release. We already had the trim function for trimming both sides of a string, but now you can trim only the left or right side of a string if that's what you need.  The usage is simple:  Example &lt;span&gt;{{ &quot; Textwire &quot;.trim() }}&lt;/span&gt;   Output &lt;span&gt;Textwire&lt;/span&gt;   You can also pass a string of characters to trim from a string:  Example &lt;span&gt;{{ &quot;_Textwire&quot;.trimLeft('_') }}&lt;/span&gt;   Output &lt;span&gt;Textwire&lt;/span&gt;   ","version":null,"tagName":"h2"},{"title":"New repeat Function‚Äã","type":1,"pageTitle":"v2.4.0 Release Notes","url":"/blog/2025/01/10/textwire-v2.4.0#new-repeat-function","content":" A new function repeat is added to strings. The function repeats a string a specified number of times. The function takes a single argument, the number of times to repeat the string.  Example &lt;span&gt;{{ 'ü§£'.repeat(5) }}&lt;/span&gt;   Output &lt;span&gt;ü§£ü§£ü§£ü§£ü§£&lt;/span&gt;   ","version":null,"tagName":"h2"},{"title":"New append and prepend Functions‚Äã","type":1,"pageTitle":"v2.4.0 Release Notes","url":"/blog/2025/01/10/textwire-v2.4.0#new-append-and-prepend-functions","content":" Two new functions append and prepend are added to arrays. The append function adds one or more elements to the end of an array and returns a new array. The prepend function adds one or more elements to the beginning of an array and returns a new array.  Example &lt;span&gt;{{ [&quot;one&quot;, &quot;two&quot;].append(&quot;three&quot;, &quot;four&quot;) }}&lt;/span&gt;   Output &lt;span&gt;one, two, three, four&lt;/span&gt;   Example &lt;span&gt;{{ [&quot;one&quot;, &quot;two&quot;].prepend(&quot;three&quot;, &quot;four&quot;) }}&lt;/span&gt;   Output &lt;span&gt;three, four, one, two&lt;/span&gt;   ","version":null,"tagName":"h2"},{"title":"New @dump Directive‚Äã","type":1,"pageTitle":"v2.4.0 Release Notes","url":"/blog/2025/01/10/textwire-v2.4.0#new-dump-directive","content":" The @dump directive is used for debugging purposes. It will print the value of the passed variables, objects, arrays, etc. to the output. Here is an example of using the @dump directive:  Example &lt;h1&gt;This is my title&lt;/h1&gt; @dump({ name: &quot;John&quot;, age: 25, admin: false, hobbies: [&quot;reading&quot;, &quot;coding&quot;], }) &lt;p&gt;Some content&lt;/p&gt;   The output would look like something like this:    It's an easy and convenient way to debug your templates and see what's going on inside of them. ","version":null,"tagName":"h2"},{"title":"Boolean Functions","type":0,"sectionRef":"#","url":"/docs/v2/functions/bool","content":"","keywords":"","version":null},{"title":"binary‚Äã","type":1,"pageTitle":"Boolean Functions","url":"/docs/v2/functions/bool#binary","content":" binary(): int   Returns an integer 1 if the receiver is true, 0 otherwise  Input example‚Äã  {{ true.binary() }} {{ false.binary() }}   Output‚Äã  1 0   ","version":null,"tagName":"h2"},{"title":"then‚Äã","type":1,"pageTitle":"Boolean Functions","url":"/docs/v2/functions/bool#then","content":" then(consequence: any, alternative?: any = nil): any   Returns the consequence if the receiver is true, otherwise returns the alternative. The alternative is optional and defaults to nil  Arguments‚Äã  consequence (any) - The value to return if the receiver is truealternative (any) - The value to return if the receiver is false. Default is nil, which will be converted to an empty string when rendered in the template  Input example‚Äã  {{ true.then(&quot;Yes&quot;, &quot;No&quot;) }} {{ false.then(&quot;Yes&quot;, &quot;No&quot;) }} {{ false.then(&quot;Yes&quot;) }}   Output‚Äã  Yes No  ","version":null,"tagName":"h2"},{"title":"Float Functions","type":0,"sectionRef":"#","url":"/docs/v2/functions/float","content":"","keywords":"","version":null},{"title":"abs‚Äã","type":1,"pageTitle":"Float Functions","url":"/docs/v2/functions/float#abs","content":" abs(): float   Returns the absolute value of a float. If the float is negative, it will return the positive value of it  Input example‚Äã  {{ -5.125.abs() }}   Output‚Äã  5.125   ","version":null,"tagName":"h2"},{"title":"ceil‚Äã","type":1,"pageTitle":"Float Functions","url":"/docs/v2/functions/float#ceil","content":" ceil(): int   Returns the rounded up value of a float to the nearest integer  Input example‚Äã  {{ 5.125.ceil() }}   Output‚Äã  6   ","version":null,"tagName":"h2"},{"title":"floor‚Äã","type":1,"pageTitle":"Float Functions","url":"/docs/v2/functions/float#floor","content":" floor(): int   Returns the rounded down value of a float to the nearest integer  Input example‚Äã  {{ 5.125.floor() }}   Output‚Äã  5   ","version":null,"tagName":"h2"},{"title":"int‚Äã","type":1,"pageTitle":"Float Functions","url":"/docs/v2/functions/float#int","content":" int(): int   Converts a float to an integer by removing the decimal part of the number. It doesn't round the number, it just removes the decimal part  Input example‚Äã  {{ 5.5.int() }}   Output‚Äã  5   ","version":null,"tagName":"h2"},{"title":"str‚Äã","type":1,"pageTitle":"Float Functions","url":"/docs/v2/functions/float#str","content":" str(): str   Converts a float to a string. It's useful when you want to manipulate the float as a string. For displaying the float, you don't need to use this function, as Textwire automatically converts the float to a string when displaying it  Input example‚Äã  {{ 5.125.str() }}   Output‚Äã  5.125  ","version":null,"tagName":"h2"},{"title":"Get Started","type":0,"sectionRef":"#","url":"/docs/v2/get-started","content":"","keywords":"","version":null},{"title":"Requirements‚Äã","type":1,"pageTitle":"Get Started","url":"/docs/v2/get-started#requirements","content":" Go 1.13 or higher is required to use Textwire. If you don't have Go installed on your machine, you can download it from the official Go website.  ","version":null,"tagName":"h2"},{"title":"Installation‚Äã","type":1,"pageTitle":"Get Started","url":"/docs/v2/get-started#installation","content":" Install the Textwire package in your Go environment. You can do this by running the following command:  go get -u github.com/textwire/textwire/v2  ","version":null,"tagName":"h2"},{"title":"Integer Functions","type":0,"sectionRef":"#","url":"/docs/v2/functions/int","content":"","keywords":"","version":null},{"title":"abs‚Äã","type":1,"pageTitle":"Integer Functions","url":"/docs/v2/functions/int#abs","content":" abs(): int   Returns the absolute value of an integer. If the integer is negative, it will return the positive value of it  Input example‚Äã  {{ -5.abs() }}   Output‚Äã  5   ","version":null,"tagName":"h2"},{"title":"decimal‚Äã","type":1,"pageTitle":"Integer Functions","url":"/docs/v2/functions/int#decimal","content":" Read about this function HERE  ","version":null,"tagName":"h2"},{"title":"float‚Äã","type":1,"pageTitle":"Integer Functions","url":"/docs/v2/functions/int#float","content":" float(): float   Converts an integer to a float by adding a decimal part of .0 to the number  Input example‚Äã  {{ 5.float() }}   Output‚Äã  5.0   ","version":null,"tagName":"h2"},{"title":"len‚Äã","type":1,"pageTitle":"Integer Functions","url":"/docs/v2/functions/int#len","content":" len(): int   Returns the number of digits in an integer. If the integer is negative, it will return the number of digits excluding the - sign  Input example‚Äã  {{ 12345.len() }}   Output‚Äã  5   ","version":null,"tagName":"h2"},{"title":"str‚Äã","type":1,"pageTitle":"Integer Functions","url":"/docs/v2/functions/int#str","content":" str(): string   Converts an integer to a string and returns it  Input example‚Äã  {{ 5.str() }} and {{ -10.str() }}   Output‚Äã  5 and -10  ","version":null,"tagName":"h2"},{"title":"Guides","type":0,"sectionRef":"#","url":"/docs/v2/guides/","content":"Guides Welcome to the Textwire Guides section, your go-to resource for mastering the Textwire. Whether you‚Äôre just starting or looking to deepen your knowledge, you‚Äôll find best practices, and step-by-step instructions to help you make the most of Textwire. Browse through our comprehensive collection of guides to learn everything from setting up Textwire to advanced customization techniques, ensuring a smooth and powerful experience. üìÑÔ∏è Usage with Templates Learn how to configure and use Textwire templates in your Go applications, including importing the package, creating template instances, and more üìÑÔ∏è Evaluate a String Learn how to evaluate a string containing Textwire code in your Go applications üìÑÔ∏è Evaluate a File Learn how to evaluate a file containing Textwire code in your Go applications using the EvaluateFile function üìÑÔ∏è Custom Functions Learn how to define and use custom functions in Textwire, enabling you to extend the functionality of Textwire by incorporating user-defined operations üìÑÔ∏è Error Handling Learn how to handle errors in Textwire, enabling you to identify and resolve issues in your project üìÑÔ∏è Configurations Learn how to setup and configure Textwire in your Go applications üìÑÔ∏è Loops Usage Learn how to use different types of loops in Textwire, including 'each' and 'for' loops","keywords":"","version":null},{"title":"String Functions","type":0,"sectionRef":"#","url":"/docs/v2/functions/str","content":"","keywords":"","version":null},{"title":"at‚Äã","type":1,"pageTitle":"String Functions","url":"/docs/v2/functions/str#at","content":" at(index?: int = 0): str   Returns the character at the given index.  When the index is out of bounds, it will return nil type, which will be converted to an empty string when rendered in the templateWhen the index is negative, it will count from the end of the string. For example, -1 will return the last character of the string  Arguments‚Äã  index (int) - The index of the character to return. Default is 0, which returns the first character of the string  Input example‚Äã  {{ &quot;Textwire&quot;.at(1) }}   Output‚Äã  e   ","version":null,"tagName":"h2"},{"title":"capitalize‚Äã","type":1,"pageTitle":"String Functions","url":"/docs/v2/functions/str#capitalize","content":" capitalize(): str   Capitalizes the first letter of a string  Input example‚Äã  {{ &quot;hello, world!&quot;.capitalize() }}   Output‚Äã  Hello, world!   ","version":null,"tagName":"h2"},{"title":"contains‚Äã","type":1,"pageTitle":"String Functions","url":"/docs/v2/functions/str#contains","content":" contains(substr: str): bool   Returns true if the string contains the given substring, otherwise false. The function is sase-sensitive, so the substring must match the case of the string  Arguments‚Äã  substr (str) - The substring to search for  Input example‚Äã  {{ &quot;Hello, World!&quot;.contains(&quot;World&quot;) }}   Output‚Äã  true   Empty substring If the substr argument is an empty string, the function will always return true. It's done this way because an empty string is always a substring of any string  Ignore case If you want to search for a substring without considering the case, you can use the lower function to convert both the string and the substring to lowercase: {{ &quot;Hello, World!&quot;.lower().contains(&quot;world&quot;) }} &lt;!-- true --&gt;   ","version":null,"tagName":"h2"},{"title":"decimal‚Äã","type":1,"pageTitle":"String Functions","url":"/docs/v2/functions/str#decimal","content":" decimal(separator?: str = &quot;.&quot;, decimals?: int = 2): str   Converts to a string with a decimal part by appending a decimal separator and the number of decimal places. Here are some rules:  When the string is not a number, it will return the string as isWhen the string is already a decimal number, it will return the string as isWhen the you use on a string, it will return the string as is if it's not a number  Arguments‚Äã  separator (str) (optional) - The separator to use for the decimal. Default is &quot;.&quot;decimals (int) (optional) - The number of decimal places add to the number. Default is 2  Input example‚Äã  {{ &quot;123&quot;.decimal() }}   Output‚Äã  123.00   ","version":null,"tagName":"h2"},{"title":"first‚Äã","type":1,"pageTitle":"String Functions","url":"/docs/v2/functions/str#first","content":" first(): str   Returns the first character of a string. When the index is out of bounds, it will return nil type, which will be converted to an empty string when rendered in the template  Input example‚Äã  {{ &quot;Textwire&quot;.first() }}   Output‚Äã  T   ","version":null,"tagName":"h2"},{"title":"last‚Äã","type":1,"pageTitle":"String Functions","url":"/docs/v2/functions/str#last","content":" last(): str   Returns the last character of a string. When the index is out of bounds, it will return nil type, which will be converted to an empty string when rendered in the template  Input example‚Äã  {{ &quot;Textwire&quot;.last() }}   Output‚Äã  e   ","version":null,"tagName":"h2"},{"title":"len‚Äã","type":1,"pageTitle":"String Functions","url":"/docs/v2/functions/str#len","content":" len(): int   Returns the length of the string  Input example‚Äã  {{ &quot;Hello, World!&quot;.len() }}   Output‚Äã  13   ","version":null,"tagName":"h2"},{"title":"lower‚Äã","type":1,"pageTitle":"String Functions","url":"/docs/v2/functions/str#lower","content":" lower(): str   Converts a string to lowercase  Input example‚Äã  {{ &quot;Hello, World!&quot;.lower() }}   Output‚Äã  hello, world!   ","version":null,"tagName":"h2"},{"title":"raw‚Äã","type":1,"pageTitle":"String Functions","url":"/docs/v2/functions/str#raw","content":" raw(): str   Function raw is used to render a string as raw HTML. This is useful when you want to render HTML tags from a string. By default, HTML tags in a string are escaped to prevent XSS attacks  Input example‚Äã  {{ &quot;&lt;h1&gt;Test&lt;/h1&gt;&quot;.raw() }}   Output‚Äã  &lt;h1&gt;Test&lt;/h1&gt;   ","version":null,"tagName":"h2"},{"title":"repeat‚Äã","type":1,"pageTitle":"String Functions","url":"/docs/v2/functions/str#repeat","content":" repeat(times: int): str   Returns a new string consisting of count copies of the string on which it was called  Arguments‚Äã  times (int) - The number of times to repeat the string  Input example‚Äã  {{ &quot;Hello&quot;.repeat(3) }}   Output‚Äã  HelloHelloHello   ","version":null,"tagName":"h2"},{"title":"reverse‚Äã","type":1,"pageTitle":"String Functions","url":"/docs/v2/functions/str#reverse","content":" reverse(): str   Returns a string with the characters reversed  Input example‚Äã  {{ &quot;stressed&quot;.reverse() }}   Output‚Äã  desserts   ","version":null,"tagName":"h2"},{"title":"split‚Äã","type":1,"pageTitle":"String Functions","url":"/docs/v2/functions/str#split","content":" split(separator?: str = &quot; &quot;): arr   Function split is used to split a string into an array of substrings. It takes an optional argument separator which is used to split the string. If no separator is provided, it defaults to a space  Arguments‚Äã  separator (str) (optional) - What separator to use to split the string. Default is &quot; &quot; (space)  Input example‚Äã  &lt;div&gt;{{ &quot;one two&quot;.split(&quot; &quot;) }}&lt;/div&gt;   Output‚Äã  &lt;div&gt;one, two&lt;/div&gt;   ","version":null,"tagName":"h2"},{"title":"trim‚Äã","type":1,"pageTitle":"String Functions","url":"/docs/v2/functions/str#trim","content":" trim(chars?: str = &quot;\\t \\n\\r&quot;): str   Trims a string from spaces and special characters like tabs, spaces and new lines by default. You can pass a argument to trim a specific set of characters from a string  Arguments‚Äã  chars (str) (optional) - A string of characters to trim from a string. Default is &quot;\\t \\n\\r&quot;  Input example‚Äã  &lt;span&gt;{{ &quot; Textwire &quot;.trim() }}&lt;/span&gt;   Output‚Äã  &lt;span&gt;Textwire&lt;/span&gt;   ","version":null,"tagName":"h2"},{"title":"trimLeft‚Äã","type":1,"pageTitle":"String Functions","url":"/docs/v2/functions/str#trimleft","content":" trimLeft(chars?: str = &quot;\\t \\n\\r&quot;): str   Trims left side of a string from spaces and special characters like tabs, spaces and new lines by default. You can pass a argument to trim a specific set of characters from a string  Arguments‚Äã  chars (str) (optional) - A string of characters to trim from a string. Default is &quot;\\t \\n\\r&quot;  Input example‚Äã  &lt;span&gt;{{ &quot; Textwire&quot;.trimLeft() }}&lt;/span&gt;   Output‚Äã  &lt;span&gt;Textwire&lt;/span&gt;   ","version":null,"tagName":"h2"},{"title":"trimRight‚Äã","type":1,"pageTitle":"String Functions","url":"/docs/v2/functions/str#trimright","content":" trimRight(chars?: str = &quot;\\t \\n\\r&quot;): str   Trims right side of a string from spaces and special characters like tabs, spaces and new lines by default. You can pass a argument to trim a specific set of characters from a string  Arguments‚Äã  chars (str) (optional) - A string of characters to trim from a string. Default is &quot;\\t \\n\\r&quot;  Input example‚Äã  &lt;span&gt;{{ &quot;Textwire &quot;.trimRight() }}&lt;/span&gt;   Output‚Äã  &lt;span&gt;Textwire&lt;/span&gt;   ","version":null,"tagName":"h2"},{"title":"truncate‚Äã","type":1,"pageTitle":"String Functions","url":"/docs/v2/functions/str#truncate","content":" truncate(length: int, ellipsis: str = &quot;...&quot;): str   Returns a string truncated to the given length with an optional ellipsis at the end  Arguments‚Äã  length (int) - The length to truncate the string toellipsis (str) (optional) - The ellipsis to append to the truncated string. Default is &quot;...&quot;  Input example‚Äã  {{ &quot;Hello, World!&quot;.truncate(5) }}   Output‚Äã  Hello...   ","version":null,"tagName":"h2"},{"title":"upper‚Äã","type":1,"pageTitle":"String Functions","url":"/docs/v2/functions/str#upper","content":" upper(): str   Converts a string to uppercase  Input example‚Äã  {{ &quot;Hello, World!&quot;.upper() }}   Output‚Äã  HELLO, WORLD!  ","version":null,"tagName":"h2"},{"title":"Array Functions","type":0,"sectionRef":"#","url":"/docs/v2/functions/arr","content":"","keywords":"","version":null},{"title":"append‚Äã","type":1,"pageTitle":"Array Functions","url":"/docs/v2/functions/arr#append","content":" append(elem: any...): arr   Adds one or more elements to the end of an array and returns a new array  Arguments‚Äã  elem (any) - Any amount of elements to add to the array  Input example:‚Äã  {{ [&quot;one&quot;, &quot;two&quot;].append(&quot;three&quot;, &quot;four&quot;) }}   Output:‚Äã  one, two, three, four   ","version":null,"tagName":"h2"},{"title":"contains‚Äã","type":1,"pageTitle":"Array Functions","url":"/docs/v2/functions/arr#contains","content":" contains(elem?: any): bool   Returns true if the array contains the given element, otherwise false  Arguments‚Äã  elem (any) - The element to search for in the array. Can be any type, including objects and arrays  Input example:‚Äã  {{ [&quot;one&quot;, &quot;two&quot;].contains(&quot;two&quot;) }}   Output:‚Äã  1   Notes‚Äã  You can do deep comparison with objects and arrays as well  {{ obj = { name: 'Anna' }; [obj].contains(obj) }}   Keep in mind that the order of objects fields doesn't matter in the comparison, but the order of array elements does matter, because each element has a unique index. [1, 2] and [2, 1] are different arrays.  ","version":null,"tagName":"h2"},{"title":"join‚Äã","type":1,"pageTitle":"Array Functions","url":"/docs/v2/functions/arr#join","content":" join(separator?: str = &quot;,&quot;): str   Joins the elements of an array into a string and returns it. It takes an optional argument separator which is used to join the elements. If no separator is provided, it defaults to a comma  Arguments‚Äã  separator (str) (optional) - What separator to use to join the elements. Default is &quot;,&quot; (comma)  Input example:‚Äã  {{ [&quot;one&quot;, &quot;two&quot;].join(&quot; &quot;) }}   Output:‚Äã  one two   ","version":null,"tagName":"h2"},{"title":"len‚Äã","type":1,"pageTitle":"Array Functions","url":"/docs/v2/functions/arr#len","content":" len(): int   Returns the length of an array  Input example:‚Äã  {{ [1, 2, 3].len() }}   Output:‚Äã  3   ","version":null,"tagName":"h2"},{"title":"prepend‚Äã","type":1,"pageTitle":"Array Functions","url":"/docs/v2/functions/arr#prepend","content":" prepend(elem: any...): arr   Adds one or more elements to the beginning of an array and returns a new array  Arguments‚Äã  elem (any) - Any amount of elements to add to the array  Input example:‚Äã  {{ [&quot;three&quot;, &quot;four&quot;].prepend(&quot;one&quot;, &quot;two&quot;) }}   Output:‚Äã  one, two, three, four   ","version":null,"tagName":"h2"},{"title":"rand‚Äã","type":1,"pageTitle":"Array Functions","url":"/docs/v2/functions/arr#rand","content":" rand(): any   Returns a random element from the array. The return type depends on the type of elements in the array.  Input example:‚Äã  {{ [1, 2, 3].rand() }}   Output:‚Äã  2   ","version":null,"tagName":"h2"},{"title":"reverse‚Äã","type":1,"pageTitle":"Array Functions","url":"/docs/v2/functions/arr#reverse","content":" reverse(): arr   Reverses the elements of an array and returns a new array  Input example:‚Äã  {{ [1, 2, 3].reverse() }}   Output:‚Äã  3, 2, 1   ","version":null,"tagName":"h2"},{"title":"shuffle‚Äã","type":1,"pageTitle":"Array Functions","url":"/docs/v2/functions/arr#shuffle","content":" shuffle(): arr   Shuffles the elements of an array and returns a new array  Input example:‚Äã  {{ [1, 2, 3, 5].shuffle() }}   Output:‚Äã  &lt;!-- The order of the elements will be random --&gt; 2, 1, 3, 5   ","version":null,"tagName":"h2"},{"title":"slice‚Äã","type":1,"pageTitle":"Array Functions","url":"/docs/v2/functions/arr#slice","content":" slice(start: int, end?: int): arr   Returns a portion of an array. The start argument is the index at which to begin the slice. The end argument is the index at which to end the slice. If end is not provided, it slices to the end of the array  Arguments‚Äã  start (int) - The index at which to begin the sliceend (int) (optional) - The index at which to end the slice  Input example:‚Äã  {{ [1, 2, 3, 4, 5].slice(1, 3) }}   Output:‚Äã  2, 3   No negative arguments start and end arguments cannot be negative. If you provide a negative value for start, it will be treated as 0. If you provide a negative value for end or the value will exceed the length of the array, it will default to a value of the last index of the array ","version":null,"tagName":"h2"},{"title":"Configurations","type":0,"sectionRef":"#","url":"/docs/v2/guides/configurations","content":"","keywords":"","version":null},{"title":"Setting Configurations‚Äã","type":1,"pageTitle":"Configurations","url":"/docs/v2/guides/configurations#setting-configurations","content":" To learn how to set configurations using textwire.NewTemplate, refer to the Usage with Templates guide. Below is a basic example of setting configurations with textwire.Configure:  import ( &quot;github.com/textwire/textwire/v2&quot; &quot;github.com/textwire/textwire/v2/config&quot; ) func main() { textwire.Configure(&amp;config.Config{ TemplateDir: &quot;templates&quot;, TemplateExt: &quot;.tw&quot;, // recommended to use .tw extension }) }   In the example above the TemplateDir and TemplateExt make sense only if you use Textwire as a template engine for your project. For things like evaluating a single Textwire file or a string, you don't need to set these configurations.  All the configurations in Textwire are optional, because each configuration has a default value. Read more about the available configurations below.  ","version":null,"tagName":"h2"},{"title":"Available Configurations‚Äã","type":1,"pageTitle":"Configurations","url":"/docs/v2/guides/configurations#available-configurations","content":" Property\tType\tDescription of the configuration\tDefault valueTemplateDir\tstring\tThe directory where Textwire will look for template files\t&quot;templates&quot; TemplateExt\tstring\tThe extension of the template files\t&quot;.tw.html&quot; ErrorPagePath\tstring\tThe relative path to the custom error page. It's relative to the TemplateDir directory. Custom error page is displayed only when DebugMode is set to false\t&quot;&quot; DebugMode\tbool\tIs a flag to enable the debug mode. With this mode enabled you can see error messages in the browser. Read about the error handling here\tfalse  Recommended We recommend using the TemplateExt setting with the .tw extension. The .tw.html extension is longer and may be deprecated in future major versions of Textwire.  Losing Extension Features If you are using VSCode and change the TemplateExt setting to anything other than .tw or .tw.html, you will lose syntax highlighting for Textwire files provided by the Textwire extension. To retain full extension functionality, change the extension to .tw for Textwire files. ","version":null,"tagName":"h2"},{"title":"Evaluate a File","type":0,"sectionRef":"#","url":"/docs/v2/guides/eval-file","content":"Evaluate a File Evaluating a file can be done with the EvaluateFile function. The EvaluateFile function accepts a path to the file that contains Textwire code and a map of variables that you want to inject into the file. Here is an example: path := &quot;path/to/file.tw&quot; result, err := textwire.EvaluateFile(path, map[string]interface{}{ &quot;name&quot;: &quot;Anna&quot;, &quot;age&quot;: 25, }) if err != nil { log.Fatal(err) } ","keywords":"","version":null},{"title":"Error Handling","type":0,"sectionRef":"#","url":"/docs/v2/guides/error-handling","content":"","keywords":"","version":null},{"title":"When Do Errors Occur?‚Äã","type":1,"pageTitle":"Error Handling","url":"/docs/v2/guides/error-handling#when-do-errors-occur","content":" Errors in Textwire can arise from a variety of situations. For instance, calling a non-existent function will result in an error. Regardless of whether you're parsing a string or a file, errors will be returned to your Go code. Below are common scenarios that may lead to errors:  ","version":null,"tagName":"h2"},{"title":"Common Error Cases‚Äã","type":1,"pageTitle":"Error Handling","url":"/docs/v2/guides/error-handling#common-error-cases","content":" Incorrect Argument Types: Passing an argument of the wrong type to a function (e.g., passing an integer to a function that expects a string).Division by Zero: Attempting to divide by zero will result in an error.Undefined Functions: Using a function that does not exist in Textwire will trigger a detailed error message.Undefined Variables: Referencing a variable that has not been defined.Unsupported Function Calls: Calling a function on a value type that does not support it.Undefined @insert Statements: Using an @insert with a name that is not defined in the layout file.Duplicate @insert or @slot Statements: Defining the same @insert or @slot statement multiple times in a layout file with the same name.Invalid Layout File Paths: Specifying a layout file path that does not exist, such as @use('~something').  Textwire will return detailed error messages in each of these scenarios, helping you quickly identify and resolve issues in your project.  ","version":null,"tagName":"h3"},{"title":"Handling errors in Textwire‚Äã","type":1,"pageTitle":"Error Handling","url":"/docs/v2/guides/error-handling#handling-errors-in-textwire","content":" Handling errors in Textwire are handled in you Go code. Let's say you are evaluating a string that contains Textwire code with an incorrect function usage:  inp := &quot;{{ name.split(1) }}&quot; result, err := textwire.EvaluateString(inp, map[string]interface{}{ &quot;name&quot;: &quot;Serhii Cho&quot;, }) if err != nil { // handle the error }   The split function requires a string as an argument, not an integer. If an incorrect argument type is passed, Textwire will return an error from the EvaluateString function, which you can handle as needed.  In the same way you handle errors with evaluating a file or working with templating system.  ","version":null,"tagName":"h2"},{"title":"Error Page‚Äã","type":1,"pageTitle":"Error Handling","url":"/docs/v2/guides/error-handling#error-page","content":" Single File or String Evaluation: If an error occurs while evaluating a single file or string, the output will be empty.Templating System: When using Textwire as a templating system, an error page will be rendered instead. This is a static HTML page displayed when an error occurs.  The error page is fully customizable, and you can configure its path in the configuration.  info When an error occurs, we cannot serve you the output to the frontend. The wrong usage of functions will lead to wrong function output, which can result in wrong data being displayed on the frontend. For better security and data integrity, the best way is to prevent the user of your site to see the output. You can read more about this here in the FAQ section.  ","version":null,"tagName":"h2"},{"title":"Error in Production‚Äã","type":1,"pageTitle":"Error Handling","url":"/docs/v2/guides/error-handling#error-in-production","content":" When something goes wrong with your Textwire code, you'll get pre-defined HTML with the static message displayed. This is what people would see when your app is in production:    ","version":null,"tagName":"h3"},{"title":"Error with Debug Mode‚Äã","type":1,"pageTitle":"Error Handling","url":"/docs/v2/guides/error-handling#error-with-debug-mode","content":" When you enable the DebugMode in Textwire, you can see the error message in the browser. This is useful when you are developing your application and want to see the error message in the browser. This is what you would see when the DebugMode is set to true:    ","version":null,"tagName":"h3"},{"title":"Custom Error Page‚Äã","type":1,"pageTitle":"Error Handling","url":"/docs/v2/guides/error-handling#custom-error-page","content":" If you want to define your own error page, you can do so by creating a new HTML file and setting the ErrorPagePath configuration to the path of the HTML file. You can read about configurations in the Available Configurations section.  This is useful when you want to display a custom error message to your users and use your own design for the error page, including the layout usage. For example, you can create a custom error page like this:  @use('~main') @insert('title', 'About Us') @insert('content') &lt;h1&gt;Oops!&lt;/h1&gt; &lt;p&gt;Something went wrong.&lt;/p&gt; &lt;p&gt;&lt;a href=&quot;/&quot;&gt;Go back to home&lt;/a&gt;&lt;/p&gt; @end   This file should be saved somewhere in your templates directory that you have specified in the configuration by TemplateDir key. Recommended to save it in the root of templates directory with the name error-page.tw.  Here is the example of how you can set the ErrorPagePath configuration:  func main() { // ... tpl, err = textwire.NewTemplate(&amp;config.Config{ TemplateExt: &quot;.tw&quot;, ErrorPagePath: &quot;error-page&quot;, DebugMode: true, }) // ... }   Since TemplateDir is set to templates by default, the ErrorPagePath will look for the file in the templates directory.  Custom Page and Debug Mode Custom error pages are rendered only when DebugMode is set to false. Otherwise, the default error page will be displayed. ","version":null,"tagName":"h3"},{"title":"Evaluate a string","type":0,"sectionRef":"#","url":"/docs/v2/guides/eval-string","content":"Evaluate a string You can use the EvaluateString function to compile and evaluate a string containing Textwire code. The EvaluateString function accepts a string and a map of variables that you want to inject into the string. After evaluating the string, the function returns the evaluated string. This is useful when you want to inject variables into an email template or any other string that contains Textwire code. Here is an example: inp := `Hello &lt;b&gt;{{ name }}&lt;/b&gt;! Congratulations on your {{ age }}th birthday!` result, err := textwire.EvaluateString(inp, map[string]interface{}{ &quot;name&quot;: &quot;Serhii&quot;, &quot;age&quot;: 33 }) if err != nil { log.Fatal(err) } ","keywords":"","version":null},{"title":"Loops Usage","type":0,"sectionRef":"#","url":"/docs/v2/guides/loops","content":"","keywords":"","version":null},{"title":"Break and Continue‚Äã","type":1,"pageTitle":"Loops Usage","url":"/docs/v2/guides/loops#break-and-continue","content":" In most programming languages, you can use break and continue statements to break or continue a loop. Textwire has similar functionality, but it is implemented as directives with the @ symbol.  For convenience, you also have @breakIf() and @continueIf() directives. They accept a single argument, which is a condition that needs to be met to break or continue the loop. Here is an example:  @each(num in [0, 1]) @breakIf(num == 1) &lt;p&gt;{{ name }}&lt;/p&gt; @end   When the condition is false, the directive does nothing. When the condition is true, the loop is broken or continued.  ","version":null,"tagName":"h2"},{"title":"Loop Variables‚Äã","type":1,"pageTitle":"Loops Usage","url":"/docs/v2/guides/loops#loop-variables","content":" Inside of every each and for loop, you have an access to a loop object. It allows you to get the current iteration index or other data that is updated on every iteration.  For example, {{ loop.index }} will return the current iteration index starting from 0. {{ loop.first }} will return true if it is the first iteration. Here is a list of all the properties of the loop object you can use:  Property\tType\tDescriptionindex\tInteger\tCurrent index number starting from 0 first\tBoolean\tIs the first item in a loop last\tBoolean\tIs the last item in a loop iter\tInteger\tCurrent iteration number starting from 1  ","version":null,"tagName":"h2"},{"title":"Example‚Äã","type":1,"pageTitle":"Loops Usage","url":"/docs/v2/guides/loops#example","content":" {{ names = [&quot;Anna&quot;, &quot;Serhii&quot;, &quot;Vladimir&quot;] }} &lt;ul&gt; @each(name in names) &lt;li&gt;{{ loop.iter }}. {{ name }}&lt;/li&gt; @end &lt;/ul&gt;   ","version":null,"tagName":"h3"},{"title":"Output‚Äã","type":1,"pageTitle":"Loops Usage","url":"/docs/v2/guides/loops#output","content":" &lt;ul&gt; &lt;li&gt;1. Anna&lt;/li&gt; &lt;li&gt;2. Serhii&lt;/li&gt; &lt;li&gt;3. Vladimir&lt;/li&gt; &lt;/ul&gt;   It's a very useful feature that removes the need to create additional variables to track the iteration index or other data.  ","version":null,"tagName":"h3"},{"title":"Else Statement‚Äã","type":1,"pageTitle":"Loops Usage","url":"/docs/v2/guides/loops#else-statement","content":" Optionally, you can use the @else statement to render content when the array is empty. It is similar to the else statement in the @if statement. Here is an example:  @each(name in []) &lt;p&gt;{{ name }}&lt;/p&gt; @else &lt;p&gt;No names&lt;/p&gt; @end   The result will be &lt;p&gt;No names&lt;/p&gt; because the array is empty. If you remove the @else statement, nothing will be rendered.  With for loops, the @else statement will behave the same way. The body of the @else statement will be rendered when the loop is not executed. ","version":null,"tagName":"h2"},{"title":"Custom Functions","type":0,"sectionRef":"#","url":"/docs/v2/guides/custom-functions","content":"","keywords":"","version":null},{"title":"Introduction‚Äã","type":1,"pageTitle":"Custom Functions","url":"/docs/v2/guides/custom-functions#introduction","content":" Custom functions are user-defined functions in your Go code that extend Textwire‚Äôs capabilities beyond what built-in functions offer. They were introduced in Textwire v2.0.0 by suggestion from @joeyjurjens.  You can attach custom functions to any data type in Textwire and invoke them on a value using the dot operator . followed by the function name.  Custom functions can take any number of arguments and return a value of any type. They can be used to perform any operations and return any value of any type.  info Custom function were introduced in Textwire v2.0.0 by suggestion from @joeyjurjens in the issue #48  ","version":null,"tagName":"h2"},{"title":"Defining custom functions‚Äã","type":1,"pageTitle":"Custom Functions","url":"/docs/v2/guides/custom-functions#defining-custom-functions","content":" To define a custom function, you need to create a function in your Go code. Here is an example of defining a upperLast function that converts the last character of a string to uppercase:  package main import ( &quot;fmt&quot; &quot;log&quot; &quot;unicode&quot; &quot;github.com/textwire/textwire/v2&quot; ) func main() { err := textwire.RegisterStrFunc(&quot;_upperLast&quot;, func(s string, args ...interface{}) string { runes := []rune(s) if len(runes) &gt; 0 { runes[len(runes)-1] = unicode.ToUpper(runes[len(runes)-1]) } return string(runes) }) if err != nil { log.Fatal(err) } }   You can now use the _upperLast function anywhere in your Textwire code.  Prefix custom functions To avoid conflicts with built-in functions, it‚Äôs recommended to prefix your custom functions with an underscore (_). Since built-in functions take precedence over custom ones, defining a custom function with the same name as a built-in function will cause the built-in function to be used. By adding an underscore prefix, you can prevent these conflicts. For example: {{ name._upperLast() }}  ","version":null,"tagName":"h2"},{"title":"Using custom functions‚Äã","type":1,"pageTitle":"Custom Functions","url":"/docs/v2/guides/custom-functions#using-custom-functions","content":" Here is the example of using the upperLast function in Textwire after defining it:  package main import ( &quot;fmt&quot; &quot;log&quot; &quot;unicode&quot; &quot;github.com/textwire/textwire/v2&quot; ) func main() { err := textwire.RegisterStrFunc(&quot;upperLast&quot;, func(s string, args ...interface{}) string { runes := []rune(s) if len(runes) &gt; 0 { runes[len(runes)-1] = unicode.ToUpper(runes[len(runes)-1]) } return string(runes) }) if err != nil { log.Fatal(err) } twCode := &quot;&lt;h1&gt;{{ 'hello'.upperLast() }}&lt;/h1&gt;&quot; output, err := textwire.EvaluateString(twCode, nil) if err != nil { log.Fatal(err) } fmt.Println(output) // Output: &lt;h1&gt;hellO&lt;/h1&gt; }   Performance warning Custom functions are not as performant as built-in functions because they are defined in Go code. When you use a custom function, first it needs to be translated from Go to Textwire, which can be slower than built-in functions. Therefore, I would recommend to create an issue with your desired built-in function, so that it can be added to Textwire if you need 100% performance. The performance difference is not noticeable, but if performance is critical for your application, you should consider creating an issue. ","version":null,"tagName":"h2"},{"title":"Usage with Templates","type":0,"sectionRef":"#","url":"/docs/v2/guides/template-usage","content":"","keywords":"","version":null},{"title":"Simple usage‚Äã","type":1,"pageTitle":"Usage with Templates","url":"/docs/v2/guides/template-usage#simple-usage","content":" To use Textwire as a template language, you need to import the github.com/textwire/textwire package and create a new Template instance. You can ether pass nil or a *textwire.Config to the NewTemplate function. The *textwire.Config is used to configure the template language. Read more about configurations in Textwire.  main.go import ( &quot;fmt&quot; &quot;net/http&quot; &quot;github.com/textwire/textwire/v2&quot; ) var tpl *textwire.Template func main() { var err error tpl, err = textwire.NewTemplate(nil) if err != nil { fmt.Println(err) } http.HandleFunc(&quot;/&quot;, homeView) http.ListenAndServe(&quot;:8080&quot;, nil) }   Non of the configurations are required, because each configuration has a default value. The NewTemplate function returns 2 values:  *textwire.Template is a struct that holds the parsed templates and has methods to evaluate the templates.error is the error that might occur during any stage of the template parsing.  In return from the NewTemplate function, we get a Template object that can be used to evaluate an already parsed template.  ","version":null,"tagName":"h2"},{"title":"Configuration‚Äã","type":1,"pageTitle":"Usage with Templates","url":"/docs/v2/guides/template-usage#configuration","content":" There are a few configurations that you can pass to the NewTemplate function to configure the template language. The NewTemplate function accepts a *config.Config with several properties.  There are cases when you want to override the default file format or the directory where the template files are stored. Here is an example of how you can configure the template language:  main.go import ( &quot;fmt&quot; &quot;net/http&quot; &quot;github.com/textwire/textwire/v2&quot; &quot;github.com/textwire/textwire/v2/config&quot; ) var tpl *textwire.Template func main() { var err error tpl, err = textwire.NewTemplate(&amp;config.Config{ TemplateDir: &quot;src/templates&quot;, TemplateExt: &quot;.tw&quot;, // recommended to use .tw extension }) if err != nil { fmt.Println(err) } http.HandleFunc(&quot;/&quot;, homeView) http.ListenAndServe(&quot;:8080&quot;, nil) }   To read more about the available configurations, visit the configurations page.  ","version":null,"tagName":"h2"},{"title":"Write response to the client‚Äã","type":1,"pageTitle":"Usage with Templates","url":"/docs/v2/guides/template-usage#write-response-to-the-client","content":" You can use the Response method on Template object to write the evaluated template to the client. The Response method accepts a http.ResponseWriter object, the name of the template file, and a map of variables that you want to inject into the template. Here is an example:  main.go func homeView(w http.ResponseWriter, r *http.Request) { err := tpl.Response(w, &quot;home&quot;, map[string]interface{}{ &quot;title&quot;: &quot;Home page&quot;, &quot;names&quot;: []string{&quot;John&quot;, &quot;Jane&quot;, &quot;Jack&quot;, &quot;Jill&quot;}, &quot;showNames&quot;: true, }) if err != nil { http.Error(w, err.Error(), http.StatusInternalServerError) } }   ","version":null,"tagName":"h2"},{"title":"Layouts‚Äã","type":1,"pageTitle":"Usage with Templates","url":"/docs/v2/guides/template-usage#layouts","content":" Defining a layout in Textwire is very simple. You need to create a layout file anywhere inside of your templates directory. Many developers just create a templates/layouts/ directory for different layouts because you might have different layouts like main.tw.html, admin.tw.html, user.tw.html.  ","version":null,"tagName":"h2"},{"title":"Reserve space in the layout‚Äã","type":1,"pageTitle":"Usage with Templates","url":"/docs/v2/guides/template-usage#reserve-space-in-the-layout","content":" The reserve statement (also called directive) is used to reserve a place for dynamic content that you can insert later in the layout. For example, you can reserve a place for the title of the page and then insert it later from about-me-tw.html or contact-us.tw.html. Here is an example of a layout file:  templates/layouts/main.tw &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;@reserve(&quot;title&quot;)&lt;/title&gt; &lt;/head&gt; &lt;body&gt; @reserve(&quot;content&quot;) &lt;/body&gt; &lt;/html&gt;   We reserve spaces for the title and content of the page. These reserved spaces can then be filled with the title and content from other files that use this layout. Read the next section to learn how to insert content into reserved spaces.  ","version":null,"tagName":"h3"},{"title":"Insert content into reserved space‚Äã","type":1,"pageTitle":"Usage with Templates","url":"/docs/v2/guides/template-usage#insert-content-into-reserved-space","content":" The insert statement (directive) is used to insert content into reserved places. Insert statement can be defined in 2 ways, with and without the body. In the example below, we define the insert for &quot;title&quot; without the body, and for &quot;content&quot; with the body.  Let's take a look at the example how I would define a home.tw.html and then I'll explain each part of it:  templates/home.tw @use(&quot;layouts/main&quot;) @insert(&quot;title&quot;, &quot;Home page&quot;) @insert(&quot;content&quot;) &lt;h1&gt;Hello, World!&lt;/h1&gt; &lt;p&gt;This is a home page.&lt;/p&gt; @end   First, we tell which layout we want to use by providing a path to the layoutThen we insert the title into layout with the value &quot;Home page&quot;Then we insert the content into layout with the HTML body.  You can read more about use, insert and reserve statements on the statements page if you need more information about the syntax. ","version":null,"tagName":"h3"},{"title":"Language Elements","type":0,"sectionRef":"#","url":"/docs/v2/language-elements/","content":"","keywords":"","version":null},{"title":"Textwire Syntax‚Äã","type":1,"pageTitle":"Language Elements","url":"/docs/v2/language-elements/#textwire-syntax","content":" Textwire‚Äôs syntax is straightforward and easy to learn. Below are the key rules for writing Textwire code:  File Extensions: All HTML files intended for Textwire parsing must have a .tw.html or .tw extension. The default is .tw.html, but using the .tw extension is recommended.Code Placement: All Textwire code must either: Be enclosed within {{ }} braces, orStart with the @ symbol.  Syntax Highlighting If you use Neovim or VSCode code editor, you can use our Neovim plugin or VSCode extension to get syntax highlighting and other features for Textwire.  ","version":null,"tagName":"h2"},{"title":"Directives‚Äã","type":1,"pageTitle":"Language Elements","url":"/docs/v2/language-elements/#directives","content":" Directives are special Textwire statements that begin with the @ symbol. They are used to define layouts, insert content into reserved placeholders, and perform logical operations such as conditionals and loops. Directives can only be placed within HTML code and are not allowed inside braces statements ({{ and }}).  Key Points:‚Äã  Expressions and Variables: Directives support Textwire expressions and variables, e.g., @if(x == 1) or @use(layoutName).Closing Directives: Directives with a body, such as @if, @for, @each, and @component, must be closed using the @end keyword.  ","version":null,"tagName":"h2"},{"title":"Braces Statements‚Äã","type":1,"pageTitle":"Language Elements","url":"/docs/v2/language-elements/#braces-statements","content":" Braces statements are special Textwire constructs that begin with {{ and end with }}. They are used for defining variables, performing arithmetic operations, conditionally rendering content, and more. Braces statements can be placed anywhere in the file, except within directives.  Key Points:‚Äã  Multiple Expressions: Use a semicolon (;) to separate multiple expressions inside braces. For example: {{ x = 5; y = 10 }} Return Values: All braces statements return a string. Defining a variable like {{ x = 5 }} doesn't return anything.Expressions like {{ 5 + 5 }} will return result. In this example it's &quot;10&quot;.  ","version":null,"tagName":"h2"},{"title":"Textwire with JavaScript‚Äã","type":1,"pageTitle":"Language Elements","url":"/docs/v2/language-elements/#textwire-with-javascript","content":" Many JavaScript frameworks and libraries use the @ symbol or {{ }} for their own purposes. To avoid conflicts, you escape it with a backslash \\.  For example, \\@if(x == 1) and \\{{ x = 1 }} will not be parsed as Textwire directives or bracesstatements.  ","version":null,"tagName":"h2"},{"title":"Types and Literals‚Äã","type":1,"pageTitle":"Language Elements","url":"/docs/v2/language-elements/#types-and-literals","content":" Textwire has a different type system that Go. When you pass a variable to Textwire, it will be automatically converted to a Textwire type. Here is a list of supported types that you can pass to Textwire or define in Textwire:  Textwire type\tEquivalent Go typesStr\tstring Bool\tbool Int\tint, int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64 Float\tfloat32, float64 Nil\tnil Array\t[]string, []bool, []int, []int64, []int32, []int16, []int8, []uint, []uint64, []uint32, []uint16, []uint8, []float64, []float32 Object\tany struct can be just struct{} or a typed struct like User{} with any fields or a map type like map[string]string or something else  The biggest difference in types and type literals between Textwire and Go is that Textwire's literals have functions that you can call on them. For example, you can call a split function on a string literal like this: {{ &quot;hello world&quot;.split(&quot; &quot;) }} to get an array of strings [&quot;hello&quot;, &quot;world&quot;]. ","version":null,"tagName":"h2"},{"title":"Introduction","type":0,"sectionRef":"#","url":"/docs/v2/introduction","content":"Introduction Textwire is a domain-specific language (DSL) tailored for Go projects, designed to effortlessly embed dynamic content into text-based formats like HTML, XML, JSON or any other text-based format that you can think of. Built specifically for Go, Textwire offers a clean and intuitive syntax that makes injecting variables and logic into any text-based format simple and efficient. Syntax Highlighting If you use Neovim or VSCode code editor, you can use our Neovim plugin or VSCode extension to get syntax highlighting and other features for Textwire. With Textwire, seamlessly integrate dynamic content into your HTML files, enabling the creation of data-driven, responsive pages with ease. The syntax is designed to be familiar and easy-to-learn, especially for developers with experience in other template languages. Visit the Language Elements page to explore the full range of available statements and directives for your templates. You can use Textwire in three versatile ways: As a templating engine for web applicationsTo embed dynamic content into a stringTo embed dynamic content into a file Here is a simple example of a Textwire template: home.tw @use('~main') @insert('title', 'Welcome to Home Page') @insert('content') &lt;h1&gt;Welcome to Textwire&lt;/h1&gt; &lt;p&gt;Our team along with {{ user.name }} are glad to see you!&lt;/p&gt; &lt;div&gt; @each(book in books) @component('~book', { book }) @else &lt;h2&gt;No books found&lt;/h2&gt; @end &lt;/div&gt; @end Click the &quot;Next&quot; button below to learn more about Language Elements in Textwire.","keywords":"","version":null},{"title":"Other Information","type":0,"sectionRef":"#","url":"/docs/v2/language-elements/other","content":"","keywords":"","version":null},{"title":"Trailing Commas‚Äã","type":1,"pageTitle":"Other Information","url":"/docs/v2/language-elements/other#trailing-commas","content":" You can use trailing commas in arrays, objects and function arguments. Here is an example of using trailing commas:  {{ names = [&quot;John&quot;, &quot;Jane&quot;, &quot;Jack&quot;,] }} {{ person = { &quot;name&quot;: &quot;John&quot;, &quot;age&quot;: 25, } }} @insert( &quot;title&quot;, &quot;Home page&quot;, )   ","version":null,"tagName":"h2"},{"title":"Comments‚Äã","type":1,"pageTitle":"Other Information","url":"/docs/v2/language-elements/other#comments","content":" You can use comments in Textwire to write notes or to comment out code. Here is an example of using comments:  {{-- This is a Textwire comment --}} &lt;!-- This is an HTML comment --&gt; {{ x = 5; x }}   HTML comment will be displayed in the final HTML output, but Textwire comment will be removed from the final HTML output. It might be useful when you want to comment out some code that you don't want to be displayed in the final HTML output. ","version":null,"tagName":"h2"},{"title":"Expressions","type":0,"sectionRef":"#","url":"/docs/v2/language-elements/expressions","content":"","keywords":"","version":null},{"title":"Ternary expressions‚Äã","type":1,"pageTitle":"Expressions","url":"/docs/v2/language-elements/expressions#ternary-expressions","content":" You can use ternary expressions to conditionally render content. Here is an example of using ternary expressions:  &lt;span&gt;{{ x == 1 ? &quot;yes&quot; : &quot;no&quot; }}&lt;/span&gt;   The advantage of a &quot;ternary expression&quot; over &quot;if statement&quot; is that it can be use inside of any other expressions.  ","version":null,"tagName":"h2"},{"title":"Prefix expressions‚Äã","type":1,"pageTitle":"Expressions","url":"/docs/v2/language-elements/expressions#prefix-expressions","content":" You can use prefix expressions to negate or invert a boolean value. Here is an example of using prefix expressions:  &lt;span&gt;{{ !isTall ? &quot;Not tall&quot; : &quot;Is tall&quot; }}&lt;/span&gt; &lt;span&gt;{{ -x }}&lt;/span&gt;   ","version":null,"tagName":"h2"},{"title":"Infix expressions‚Äã","type":1,"pageTitle":"Expressions","url":"/docs/v2/language-elements/expressions#infix-expressions","content":" You can use infix expressions to perform arithmetic operations. Here is an example of using infix expressions:  &lt;ul&gt; &lt;li&gt;{{ x + y }}&lt;/li&gt; &lt;!-- Addition --&gt; &lt;li&gt;{{ x - y }}&lt;/li&gt; &lt;!-- Subtraction --&gt; &lt;li&gt;{{ x * y }}&lt;/li&gt; &lt;!-- Multiplication --&gt; &lt;li&gt;{{ x / y }}&lt;/li&gt; &lt;!-- Division --&gt; &lt;li&gt;{{ x % y }}&lt;/li&gt; &lt;!-- Modulo --&gt; &lt;li&gt;{{ (x + 2) / (y * (4 - c)) }}&lt;/li&gt; &lt;!-- Grouped expressions --&gt; &lt;/ul&gt;   ","version":null,"tagName":"h2"},{"title":"Postfix expressions‚Äã","type":1,"pageTitle":"Expressions","url":"/docs/v2/language-elements/expressions#postfix-expressions","content":" You can use postfix expressions to increment or decrement a variable. Here is an example of using postfix expressions:  &lt;span&gt;{{ x++ }}&lt;/span&gt; &lt;!-- Increment --&gt; &lt;span&gt;{{ x-- }}&lt;/span&gt; &lt;!-- Decrement --&gt;   ","version":null,"tagName":"h2"},{"title":"Comparison expressions‚Äã","type":1,"pageTitle":"Expressions","url":"/docs/v2/language-elements/expressions#comparison-expressions","content":" Comparison expressions produce a boolean value. Here is an example of using comparison expressions:  @if(x == 1) &lt;p&gt;x is 1&lt;/p&gt; @end   ","version":null,"tagName":"h2"},{"title":"Supported operators‚Äã","type":1,"pageTitle":"Expressions","url":"/docs/v2/language-elements/expressions#supported-operators","content":" All supported operators are listed in the table below:  Operator\tDescription==\tEqual !=\tNot equal &gt;\tGreater &lt;\tLess &gt;=\tGreater or equal &lt;=\tLess or equal  ","version":null,"tagName":"h3"},{"title":"Function calls‚Äã","type":1,"pageTitle":"Expressions","url":"/docs/v2/language-elements/expressions#function-calls","content":" You can use function calls to call functions. Textwire has a few built-in functions that you can use in your templates.  Functions in Textwire are type specific, which means that you can't call a function on a variable that is not of the same type as the function. For example, you can't call a split function on an integer variable.  Here is an example of using function calls:  {{ name.split(&quot; &quot;) }}   You can read more detailed about built-in functions on the Built-in Functions page. ","version":null,"tagName":"h2"},{"title":"Upgrade Guide","type":0,"sectionRef":"#","url":"/docs/v2/upgrade","content":"","keywords":"","version":null},{"title":"Upgrading To 2.0 From 1.0‚Äã","type":1,"pageTitle":"Upgrade Guide","url":"/docs/v2/upgrade#upgrading-to-20-from-10","content":" Going from version 1 to version 2 is a simple process. Follow the steps below to upgrade your Textwire code to version 2.  ","version":null,"tagName":"h2"},{"title":"1. Change the import path‚Äã","type":1,"pageTitle":"Upgrade Guide","url":"/docs/v2/upgrade#1-change-the-import-path","content":" Change all the imports in your code from github.com/textwire/textwire to github.com/textwire/textwire/v2  import &quot;github.com/textwire/textwire/v2&quot;   ","version":null,"tagName":"h3"},{"title":"2. Update the dependencies‚Äã","type":1,"pageTitle":"Upgrade Guide","url":"/docs/v2/upgrade#2-update-the-dependencies","content":" Run the command go mod tidy to update the dependencies in your go.mod file  go mod tidy   ","version":null,"tagName":"h3"},{"title":"3. Change the package name‚Äã","type":1,"pageTitle":"Upgrade Guide","url":"/docs/v2/upgrade#3-change-the-package-name","content":" Change the package name from textwire.Config to config.Config in your code if you use configuration and import &quot;github.com/textwire/textwire/v2/config&quot;. If you already have a package named config, you can alias the import like twconfig &quot;github.com/textwire/textwire/v2/config&quot;  import ( &quot;github.com/textwire/textwire/v2&quot; &quot;github.com/textwire/textwire/v2/config&quot; ) var tpl *textwire.Template func main() { var err error tpl, err = textwire.NewTemplate(&amp;config.Config{ TemplateDir: &quot;src/templates&quot;, }) if err != nil { fmt.Println(err) } }  ","version":null,"tagName":"h3"},{"title":"Literals","type":0,"sectionRef":"#","url":"/docs/v2/language-elements/literals","content":"","keywords":"","version":null},{"title":"String‚Äã","type":1,"pageTitle":"Literals","url":"/docs/v2/language-elements/literals#string","content":" You can use string literals and concatenate them with other strings. You can use double or single quotes for strings. Here is an example of using string literals:  {{ &quot;Hello&quot; + 'World!' }}   When you print a string, it will be automatically escaped. If you want to print a string without escaping it, you can use the a raw() function on strings. Example: {{ &quot;&lt;h1&gt;Test&lt;/h1&gt;&quot;.raw() }}  ","version":null,"tagName":"h2"},{"title":"Integer‚Äã","type":1,"pageTitle":"Literals","url":"/docs/v2/language-elements/literals#integer","content":" You can use integer literals and perform arithmetic operations with them. Here is an example of using integer literals:  &lt;span&gt;{{ 1 + 2 }}&lt;/span&gt;   ","version":null,"tagName":"h2"},{"title":"Nil‚Äã","type":1,"pageTitle":"Literals","url":"/docs/v2/language-elements/literals#nil","content":" You can use nil literal to check if a variable is nil. Here is an example of using nil literal:  @if(nil) &lt;p&gt;It will not be displayed&lt;/p&gt; @end   ","version":null,"tagName":"h2"},{"title":"Float‚Äã","type":1,"pageTitle":"Literals","url":"/docs/v2/language-elements/literals#float","content":" You can use float literals and perform arithmetic operations with them. Here is an example of using float literals:  &lt;span&gt;{{ 1.534 + 2.5 }}&lt;/span&gt;   Precision limit Most languages (including Textwire) use IEEE 754 standard for floating-point numbers. These floating-point types have a finite precision and are unable to accurately represent more than approximately 15-17 digits. For example 1234567890.1234567890 will be rounded to 1234567890.1234567 in Textwire because of the precision limit of floating-point numbers. If you need to work with large numbers, you can keep them as strings.  ","version":null,"tagName":"h2"},{"title":"Boolean‚Äã","type":1,"pageTitle":"Literals","url":"/docs/v2/language-elements/literals#boolean","content":" You can use boolean literals to check if a variable is true or false. Here is an example of using boolean literals:  @if(true) &lt;p&gt;Is tall&lt;/p&gt; @end   ","version":null,"tagName":"h2"},{"title":"Array‚Äã","type":1,"pageTitle":"Literals","url":"/docs/v2/language-elements/literals#array","content":" Defining an array in Textwire is done is a similar way as in other languages. Here is an example of defining an array:  {{ names = [&quot;John&quot;, &quot;Jane&quot;, &quot;Jack&quot;] }} &lt;ul&gt; @each(name in names) &lt;li&gt;{{ name }}&lt;/li&gt; &lt;li&gt;{{ loop.index }}&lt;/li&gt; {{-- Index of the current item --}} @end &lt;/ul&gt;   You can access values in an array by using an index. Here is an example of accessing values in an array:  {{ names = [&quot;John&quot;, &quot;Jane&quot;, &quot;Jack&quot;] }} &lt;ul&gt; &lt;li&gt;{{ names[0] }}&lt;/li&gt; {{-- John --}} &lt;li&gt;{{ names[1] }}&lt;/li&gt; {{-- Jane --}} &lt;li&gt;{{ names[2] }}&lt;/li&gt; {{-- Jack --}} &lt;/ul&gt;   ","version":null,"tagName":"h2"},{"title":"Object‚Äã","type":1,"pageTitle":"Literals","url":"/docs/v2/language-elements/literals#object","content":" Objects in Textwire are very similar to JavaScript object with key-value pairs. Here is an example of defining an object:  {{ person = {&quot;name&quot;: &quot;John&quot;, &quot;age&quot;: 25} }}   You can also use key names without quotes if your keys are valid identifiers:  {{ person = { name: &quot;John&quot;, age: 25 } }}   You can access values in an object by using a key. Here is an example of accessing values in an object:  {{ user = {age: 25, name: {first: &quot;Anna&quot;, last: &quot;Cho&quot;}} }} &lt;ul&gt; &lt;li&gt;First name: {{ user.name.first }}&lt;/li&gt; {{-- &quot;Anna&quot; --}} &lt;li&gt;Last name: {{ user.name.last }}&lt;/li&gt; {{-- &quot;Cho&quot; --}} &lt;li&gt;Age: {{ user.age }}&lt;/li&gt; {{-- 25 --}} &lt;/ul&gt;   Case insensitive fields Object fields are case insensitive. It means that you can access fields in an object by using any case. For example, {{ user.name.first }} and {{ user.Name.First }} will return the same value. It's done this way for convenience.  Shorthand property notation‚Äã  Similar to objects in JavaScript, you can use shorthand property notation to define an object. Here is an example of using shorthand property notation:  {{ name = &quot;John&quot;; age = 25 }} {{ person = { name, age } }}  ","version":null,"tagName":"h2"},{"title":"Statements","type":0,"sectionRef":"#","url":"/docs/v2/language-elements/statements","content":"","keywords":"","version":null},{"title":"If Statement‚Äã","type":1,"pageTitle":"Statements","url":"/docs/v2/language-elements/statements#if-statement","content":" You can use if statements to conditionally render content. You can construct @if statement using the @if, @elseif, @else and @end directives. Here is an example of using if statements:  @if(name == &quot;Anna&quot;) &lt;p&gt;Her name is Anna&lt;/p&gt; @end   You can also use else and elseif statements:  @if(x == 1) &lt;p&gt;x is 1&lt;/p&gt; @elseif(x == 2) &lt;p&gt;x is 2&lt;/p&gt; @else &lt;p&gt;x is not 1 and 2&lt;/p&gt; @end   ","version":null,"tagName":"h2"},{"title":"For Loop‚Äã","type":1,"pageTitle":"Statements","url":"/docs/v2/language-elements/statements#for-loop","content":" You can use regular for loops to iterate over an array or a range of numbers.  This is a basic for loop that you can use. It has a declaration, condition and post statement. for &lt;declaration&gt;; &lt;condition&gt;; &lt;post&gt;. They are all optional. Here is an example of using for loop:  {{ names = [&quot;Ann&quot;, &quot;Serhii&quot;] }} @for(i = 0; i &lt; names.len(); i++) &lt;p&gt;{{ names[i] }}&lt;/p&gt; @else &lt;p&gt;No names&lt;/p&gt; @end   Read More about Loops Read more about loops in the Loops guide.  Example‚Äã  {{ names = [&quot;Ann&quot;, &quot;Serhii&quot;, &quot;Vladimir&quot;] }} &lt;ul&gt; @for(i = 0; i &lt; names.len(); i++) @continueIf(names[i] == &quot;Serhii&quot;) &lt;li&gt;{{ names[i] }}&lt;/li&gt; @end &lt;/ul&gt;   ","version":null,"tagName":"h2"},{"title":"Each Loop‚Äã","type":1,"pageTitle":"Statements","url":"/docs/v2/language-elements/statements#each-loop","content":" Each statement is a special for loop that you can use to iterate over an array. It has a declaration and an array. @each(&lt;declaration&gt; in &lt;array&gt;). Here is an example of using each loop:  {{ names = [&quot;Ann&quot;, &quot;Serhii&quot;] }} @each(name in names) &lt;p&gt;{{ name }}&lt;/p&gt; @end   Read More about Loops Read more about loops in the Loops guide.  ","version":null,"tagName":"h2"},{"title":"Variable Declaration‚Äã","type":1,"pageTitle":"Statements","url":"/docs/v2/language-elements/statements#variable-declaration","content":" You can assign and declare variables by using the = operator. Here is an example of declaring variables:  {{ x = 5 }} {{ x = 10 }}   You cannot assign values to variables that have a different type. For example, you cannot do {{ x = &quot;Hello&quot;; x = 3 }} because x is a string and then you are trying to assign an integer to it. In Textwire, you don't need to declare type of a variable, it will be automatically inferred from the value that you assign to it.  Declaration has no output Variable declaration statements are not expressions! They don't return any value and can't be used inside of other expressions. Therefore, they don't print anything to the output.  ","version":null,"tagName":"h2"},{"title":"Use Statement‚Äã","type":1,"pageTitle":"Statements","url":"/docs/v2/language-elements/statements#use-statement","content":" @use statements allow you to specify a layout file that will be used to render the current template. This feature is useful for creating reusable layouts that can be applied to multiple templates.  Here is an example of using use statement:  @use(&quot;layouts/main&quot;)   Or, you can use a path alias like this:  @use(&quot;~main&quot;)   Use statement Path alias If your layouts are located in the layouts directory, you can use the ~ alias to reference them. For example, @use(&quot;~main&quot;) instead of @use(&quot;layouts/main&quot;). Behind the scenes, the ~ alias will be replaced with layouts/.  The @use statement accepts a string literal as its argument. This string literal should specify the path to the layout file relative to the TemplateDir parameter defined in the configuration. For example, if TemplateDir is set to &quot;src/templates&quot; and you have layouts directory in there, you can use the layout statement like @use(&quot;layouts/main&quot;), and it will look for the layout file at &quot;src/templates/layouts/main.tw&quot;.  Understanding the @use Directive When you use the @use directive, only the content inside @insert directives will be rendered; the rest of the file's content will be ignored. This is because the @use directive applies a layout file instead of rendering the current file directly. During this process, all placeholders reserved in the layout file are populated with the content specified within your @insert directives.  ","version":null,"tagName":"h2"},{"title":"Insert Statement‚Äã","type":1,"pageTitle":"Statements","url":"/docs/v2/language-elements/statements#insert-statement","content":" The @insert statement lets you inject content into placeholders defined by the @reserve statement in your layout file. This feature enables flexible template structuring and reusability.  Below is an example demonstrating two scenarios for the @insert statement with a content body and without:  home.tw @use(&quot;layouts/main&quot;) &lt;!-- Without a content body --&gt; @insert(&quot;title&quot;, &quot;Home page&quot;) &lt;!-- With a content body --&gt; @insert(&quot;content&quot;) &lt;h1&gt;Hello, World!&lt;/h1&gt; &lt;p&gt;This is a home page.&lt;/p&gt; @end   The @insert statement is optional and accepts two arguments: the name of the reserved placeholder and the optional content to be injected into that placeholder.  All @insert statements are evaluated within the layout file, where they are matched to placeholders defined by the @reserve statement.  Important Notes Defining an @insert for a placeholder that is not declared in the layout file using @reserve will result in an error.You cannot define multiple @insert statements with the same name in a single file.  ","version":null,"tagName":"h2"},{"title":"Reserve Statement‚Äã","type":1,"pageTitle":"Statements","url":"/docs/v2/language-elements/statements#reserve-statement","content":" When defining a layout file for your template, you can reserve placeholders for dynamic content. These placeholders can be used for elements such as the title, content, sidebar, footer, and more. Below is an example of how to use the @reserve statement:  layouts/main.tw &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;@reserve(&quot;title&quot;)&lt;/title&gt; &lt;/head&gt; &lt;body&gt; @reserve(&quot;content&quot;) &lt;/body&gt; &lt;/html&gt;   Pass Variables to the Layout All variables passed to the template file are also available in the layout file. This means you can replace @reserve(&quot;title&quot;) with {{ title }} and define the title variable in each template file. In other words, variables available in the template file can be seamlessly used within the layout file.  The @reserve statement accepts a single argument: the name of the reserved placeholder. This name will be used in the @insert statement to insert content into the corresponding placeholder.  ","version":null,"tagName":"h2"},{"title":"Component‚Äã","type":1,"pageTitle":"Statements","url":"/docs/v2/language-elements/statements#component","content":" The @component directive allows you to include reusable components within your templates. Components help organize and structure templates by encapsulating reusable parts of your UI.  To use components in Textwire, create a components directory inside your templates and store your component files there. You can then include a component in your template using the @component directive.  Here‚Äôs a simple example of using a component:  ","version":null,"tagName":"h2"},{"title":"Example of a Component‚Äã","type":1,"pageTitle":"Statements","url":"/docs/v2/language-elements/statements#example-of-a-component","content":" components/post-card.tw &lt;div class=&quot;post&quot;&gt; &lt;h1&gt;{{ post.title }}&lt;/h1&gt; &lt;p&gt;{{ post.content }}&lt;/p&gt; &lt;/div&gt;   ","version":null,"tagName":"h3"},{"title":"Example of Using a Template‚Äã","type":1,"pageTitle":"Statements","url":"/docs/v2/language-elements/statements#example-of-using-a-template","content":" home.tw &lt;div class=&quot;posts&quot;&gt; @each(post in posts) @component(&quot;components/post-card&quot;, { post }) @end &lt;/div&gt;   warning Component cannot have empty body and be like @component(&quot;components/post-card&quot;, { post })@end. In this situations it's important to remove @end token.  Component path alias If your components are located in the components directory, you can use the ~ alias to reference them. For example, @component(&quot;~post-card&quot;, { post }) instead of @component(&quot;components/post-card&quot;, { post }). Behind the scenes, the ~ alias will be replaced with components/.  The first argument of the @component directive is a path to the component file relative to the TemplateDir parameter that you set in the config.  The second optional argument is a Textwire object that you want to pass to the component. Here is another example of using a component with a second argument:  home.tw &lt;ul&gt; @each(book in books) @component(&quot;parts/book&quot;, { completed: book.completed }) @end &lt;/ul&gt;   You can also use slots in components to pass content to the component. Read about slots in the next section.  ","version":null,"tagName":"h3"},{"title":"Component Slots‚Äã","type":1,"pageTitle":"Statements","url":"/docs/v2/language-elements/statements#component-slots","content":" Component slots are a common feature in many template languages and frameworks. Textwire supports both named and default slots, allowing you to pass content into components flexibly.  There are two types of slots in Textwire: default slots and named slots.  Default Slots: Use the @slot directive to define and pass content to a default slot.Named Slots: Use the @slot(&quot;slot-name&quot;) directive to define and pass content to a named slot.  Here‚Äôs an example of how to use slots in a component. Consider this component:  components/book.tw &lt;div class=&quot;book&quot;&gt; @slot &lt;h1&gt;{{ book.title }}&lt;/h1&gt; &lt;p&gt;{{ book.description }}&lt;/p&gt; @slot('footer') &lt;/div&gt;   We can now use book.tw component in our Textwire files like this:  home.tw @each(book in books) @component(&quot;~book&quot;, { book }) @slot &lt;img src=&quot;{{ book.image }}&quot; alt=&quot;{{ book.title }}&quot;&gt; @end @slot('footer') &lt;small&gt;published by {{ book.author }}&lt;/small&gt; &lt;button&gt;Read more&lt;/button&gt; @end @end @end   In this example, both default and named slots are used within a single component. You can include as many slots as needed in a single component, provided that all named slots have unique names.  Important Note Defining multiple slots with the same name, or defining 2 default slots in a single component will result in an error.  ","version":null,"tagName":"h2"},{"title":"Dump Directive‚Äã","type":1,"pageTitle":"Statements","url":"/docs/v2/language-elements/statements#dump-directive","content":" The @dump directive will feel familiar to Laravel and Symfony users. It is primarily used for debugging purposes. This directive outputs the value of variables, objects, arrays, strings and other data types to the screen.  Here‚Äôs an example of how to use the @dump directive:  {{ names = [&quot;John&quot;, &quot;Jane&quot;, &quot;Jack&quot;, &quot;Jill&quot;] }} @dump(names)   The output would look like something like this:    ","version":null,"tagName":"h2"},{"title":"Works with Different Types‚Äã","type":1,"pageTitle":"Statements","url":"/docs/v2/language-elements/statements#works-with-different-types","content":" Similarly, you can print objects and other types of data:  &lt;h1&gt;This is my title&lt;/h1&gt; @dump({ name: &quot;John&quot;, age: 25, admin: false, hobbies: [&quot;reading&quot;, &quot;coding&quot;], }) &lt;p&gt;Some content&lt;/p&gt;     ","version":null,"tagName":"h3"},{"title":"Dump Multiple Objects‚Äã","type":1,"pageTitle":"Statements","url":"/docs/v2/language-elements/statements#dump-multiple-objects","content":" @dump directive can accept an endless amount arguments at once:  {{ meta = [1, 2.23, true, false, nil] }} {{ user = { name: &quot;John&quot;, age: 25 } }} @dump(meta, user)     It's an easy and convenient way to debug your templates and see what's going on inside of them. ","version":null,"tagName":"h3"}],"options":{"excludeRoutes":["/docs/v1/**"],"disableVersioning":true,"id":"default"}}