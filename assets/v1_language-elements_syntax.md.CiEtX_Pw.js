import{_ as t,o,c as a,ah as d}from"./chunks/framework.BKCvwjwz.js";const p=JSON.parse('{"title":"Language Elements - v1","description":"","frontmatter":{"title":"Language Elements - v1","outline":"deep"},"headers":[],"relativePath":"v1/language-elements/syntax.md","filePath":"versions/v1/language-elements/syntax.md","lastUpdated":1771265060000}'),i={name:"v1/language-elements/syntax.md"};function c(s,e,r,n,l,u){return o(),a("div",null,[...e[0]||(e[0]=[d('<h1 id="language-elements" tabindex="-1">Language Elements <a class="header-anchor" href="#language-elements" aria-label="Permalink to &quot;Language Elements&quot;">​</a></h1><p>Textwire is designed to be easy to use for Go developers. It has a similar syntax to Go, but it is a separate language and has specific grammar to make it easier to use as a template language.</p><h2 id="syntax" tabindex="-1">Syntax <a class="header-anchor" href="#syntax" aria-label="Permalink to &quot;Syntax&quot;">​</a></h2><p>Textwire has a simple syntax that is easy to learn. Here are some rules that you need to follow when writing Textwire code:</p><ul><li>All the HTML files that you want to parse with Textwire must have a <code>.tw.html</code> extension.</li><li>All the Textwire code must be inside of the <code>{{ }}</code> braces, or start with <code>@</code> symbol.</li></ul><div class="tip custom-block"><p class="custom-block-title">Syntax Highlighting</p><p>If you use Neovim or VSCode code editor, you can use our <a href="https://github.com/textwire/textwire.nvim" target="_blank" rel="noreferrer">Neovim plugin</a> or <a href="https://marketplace.visualstudio.com/items?itemName=SerhiiCho.textwire" target="_blank" rel="noreferrer">VSCode extension</a> to get syntax highlighting and other features for Textwire.</p></div><h3 id="braces-statements" tabindex="-1">Braces Statements <a class="header-anchor" href="#braces-statements" aria-label="Permalink to &quot;Braces Statements&quot;">​</a></h3><p>Braces statements are special Textwire statements that start with <code>{{</code> braces and end with <code>}}</code>. They can be used to define variables, perform arithmetic operations, conditionally render content and so on. Braces statements can be placed anywhere in the file except inside of directives.</p><ul><li>If you want multiple expressions inside <code>{{ }}</code> braces, use <code>;</code> to separate them. For example: <code>{{ x = 5; y = 10 }}</code>.</li><li>All the braces statements return a string. For example, <code>{{ x = 5 }}</code> will return an empty string, but <code>{{ 5 + 5 }}</code> will return &quot;10&quot;.</li><li>There are special braces statements that need to be closed with <code>{ end }}</code> keyword. For example, <a href="/v1/language-elements/statements#if-statement">if statement</a> and <a href="/v1/language-elements/statements#for-loop">for statements</a>.</li><li>To escape <code>{{ }}</code> braces, you can use <code>\\</code>. For example <code>\\{{ x }}</code> will not be parsed as a braces statement but as HTML.</li></ul><h3 id="directives" tabindex="-1">Directives <a class="header-anchor" href="#directives" aria-label="Permalink to &quot;Directives&quot;">​</a></h3><p>Directives are special Textwire statements that start with <code>@</code> symbol. They can be used to define a layout, insert content into reserved places, if statements and so on. Directives can be placed anywhere in the file except inside of <code>{{ }}</code> braces.</p><ul><li>To escape directive symbols, you can use <code>\\</code>. For example <code>\\@if(x == 1)</code> will not be parsed as a directive but as HTML</li><li>You can use textwire expressions and variables inside of directives. For example <code>@if(x == 1)</code> or <code>@use(layoutName)</code></li><li>All the directives with body like <code>@if</code>, <code>@for</code>, <code>@each</code>, <code>@component</code>, etc. must be closed with <code>@end</code> keyword</li></ul><h2 id="types-and-literals" tabindex="-1">Types and Literals <a class="header-anchor" href="#types-and-literals" aria-label="Permalink to &quot;Types and Literals&quot;">​</a></h2><p>Textwire has a different type system that Go. When you pass a variable to Textwire, it will be automatically converted to a Textwire type. Here is a list of supported types that you can pass to Textwire or define in Textwire:</p><table tabindex="0"><thead><tr><th>Textwire type</th><th>Equivalent Go types</th></tr></thead><tbody><tr><td><code>Str</code></td><td><code>string</code></td></tr><tr><td><code>Bool</code></td><td><code>bool</code></td></tr><tr><td><code>Int</code></td><td><code>int</code>, <code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code>, <code>uint</code>, <code>uint8</code>, <code>uint16</code>, <code>uint32</code>, <code>uint64</code></td></tr><tr><td><code>Float</code></td><td><code>float32</code>, <code>float64</code></td></tr><tr><td><code>Nil</code></td><td><code>nil</code></td></tr><tr><td><code>Array</code></td><td><code>[]string</code>, <code>[]bool</code>, <code>[]int</code>, <code>[]int64</code>, <code>[]int32</code>, <code>[]int16</code>, <code>[]int8</code>, <code>[]uint</code>, <code>[]uint64</code>, <code>[]uint32</code>, <code>[]uint16</code>, <code>[]uint8</code>, <code>[]float64</code>, <code>[]float32</code></td></tr><tr><td><code>Object</code></td><td>any struct can be just <code>struct{}</code> or a typed struct like <code>User{}</code> with any fields or a <code>map</code> type like <code>map[string]string</code> or something else</td></tr></tbody></table><p>The biggest difference in types and type literals between Textwire and Go is that Textwire&#39;s literals have functions that you can call on them. For example, you can call a <code>split</code> function on a string literal like this: <code>{{ &quot;hello world&quot;.split(&quot; &quot;) }}</code> to get an array of strings <code>[&quot;hello&quot;, &quot;world&quot;]</code>.</p>',16)])])}const m=t(i,[["render",c]]);export{p as __pageData,m as default};
