import{_ as t,o as i,c as a,ah as o}from"./chunks/framework.BKCvwjwz.js";const u=JSON.parse('{"title":"Language Elements - v2","description":"Textwire has a simple syntax that is easy to learn","frontmatter":{"title":"Language Elements - v2","description":"Textwire has a simple syntax that is easy to learn"},"headers":[],"relativePath":"v2/language-elements/syntax.md","filePath":"versions/v2/language-elements/syntax.md","lastUpdated":1772023924000}'),s={name:"v2/language-elements/syntax.md"};function n(r,e,d,c,l,h){return i(),a("div",null,[...e[0]||(e[0]=[o('<h1 id="language-elements" tabindex="-1">Language Elements <a class="header-anchor" href="#language-elements" aria-label="Permalink to &quot;Language Elements&quot;">​</a></h1><p>Textwire is designed to be intuitive for Go developers, offering a syntax that feels familiar while being tailored specifically for template usage. It&#39;s a standalone language with its own grammar designed for simplicity and ease of use.</p><h2 id="textwire-syntax" tabindex="-1">Textwire Syntax <a class="header-anchor" href="#textwire-syntax" aria-label="Permalink to &quot;Textwire Syntax&quot;">​</a></h2><p>Textwire’s syntax is straightforward and easy to learn. Below are the key rules for writing Textwire code:</p><ul><li><strong>File Extensions</strong>: All HTML files intended for Textwire parsing must have a <code>.tw</code> extension.</li><li><strong>Code Placement</strong>: All Textwire code must either: <ul><li>Be enclosed within <code>{{ }}</code> braces, or</li><li>Start with the <code>@</code> symbol.</li></ul></li></ul><div class="tip custom-block"><p class="custom-block-title">Syntax Highlighting</p><p>If you use Neovim or VSCode code editor, you can use our <a href="https://github.com/textwire/textwire.nvim" target="_blank" rel="noreferrer">Neovim plugin</a> or <a href="https://marketplace.visualstudio.com/items?itemName=SerhiiCho.textwire" target="_blank" rel="noreferrer">VSCode extension</a> to get syntax highlighting and other features for Textwire.</p></div><h2 id="directives" tabindex="-1">Directives <a class="header-anchor" href="#directives" aria-label="Permalink to &quot;Directives&quot;">​</a></h2><p>Directives are special Textwire statements that begin with the <code>@</code> symbol. They are used to define layouts, insert content into reserved placeholders, and perform logical operations such as conditionals and loops. Directives can only be placed within HTML code and are not allowed inside braces statements (<code>{{</code> and <code>}}</code>).</p><h4 id="key-points" tabindex="-1">Key Points: <a class="header-anchor" href="#key-points" aria-label="Permalink to &quot;Key Points:&quot;">​</a></h4><ul><li><strong>Expressions and Variables</strong>: Directives support Textwire expressions and variables, e.g., <code>@if(x == 1)</code> or <code>@use(layoutName)</code>.</li><li><strong>Closing Directives</strong>: Directives with a body, such as <code>@if</code>, <code>@for</code>, <code>@each</code>, and <code>@component</code>, must be closed using the <code>@end</code> keyword.</li></ul><h2 id="braces-statements" tabindex="-1">Braces Statements <a class="header-anchor" href="#braces-statements" aria-label="Permalink to &quot;Braces Statements&quot;">​</a></h2><p>Braces statements are special Textwire constructs that begin with <code>{{</code> and end with <code>}}</code>. They are used for defining variables, performing arithmetic operations, conditionally rendering content, and more. Braces statements can be placed anywhere in the file, except within directives.</p><h4 id="key-points-1" tabindex="-1">Key Points: <a class="header-anchor" href="#key-points-1" aria-label="Permalink to &quot;Key Points:&quot;">​</a></h4><ul><li><p><strong>Multiple Expressions</strong>: Use a semicolon (<code>;</code>) to separate multiple expressions inside braces. For example:</p><div class="language-textwire vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">textwire</span><pre class="shiki shiki-themes github-light catppuccin-mocha vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-light-font-style:inherit;--shiki-dark:#89B4FA;--shiki-dark-font-style:italic;">{{</span><span style="--shiki-light:#24292E;--shiki-dark:#CBA6F7;"> x</span><span style="--shiki-light:#D73A49;--shiki-dark:#CBA6F7;"> = </span><span style="--shiki-light:#005CC5;--shiki-dark:#FAB387;">5</span><span style="--shiki-light:#D73A49;--shiki-dark:#CBA6F7;">; </span><span style="--shiki-light:#24292E;--shiki-dark:#CBA6F7;">y</span><span style="--shiki-light:#D73A49;--shiki-dark:#CBA6F7;"> = </span><span style="--shiki-light:#005CC5;--shiki-dark:#FAB387;">10</span><span style="--shiki-light:#005CC5;--shiki-light-font-style:inherit;--shiki-dark:#89B4FA;--shiki-dark-font-style:italic;"> }}</span></span></code></pre></div></li><li><p><strong>Return Values</strong>: All braces statements return a string.</p></li><li><p>Defining a variable like <code>{{ x = 5 }}</code> doesn&#39;t return anything.</p></li><li><p>Expressions like <code>{{ 5 + 5 }}</code> will return result. In this example it&#39;s <code>&quot;10&quot;</code>.</p></li></ul><h2 id="textwire-with-javascript" tabindex="-1">Textwire with JavaScript <a class="header-anchor" href="#textwire-with-javascript" aria-label="Permalink to &quot;Textwire with JavaScript&quot;">​</a></h2><p>Many JavaScript frameworks and libraries use the <code>@</code> symbol or <code>{{ }}</code> for their own purposes. To avoid conflicts, you escape it with a backslash <code>\\</code>.</p><p>For example, <code>\\@if(x == 1)</code> and <code>\\{{ x = 1 }}</code> will not be parsed as Textwire directives or braces statements.</p><h2 id="types-and-literals" tabindex="-1">Types and Literals <a class="header-anchor" href="#types-and-literals" aria-label="Permalink to &quot;Types and Literals&quot;">​</a></h2><p>Textwire has a different type system that Go. When you pass a variable to Textwire, it will be automatically converted to a Textwire type. Here is a list of supported types that you can pass to Textwire or define in Textwire:</p><table tabindex="0"><thead><tr><th>Textwire type</th><th>Equivalent Go types</th></tr></thead><tbody><tr><td><code>Str</code></td><td><code>string</code></td></tr><tr><td><code>Bool</code></td><td><code>bool</code></td></tr><tr><td><code>Int</code></td><td><code>int</code>, <code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code>, <code>uint</code>, <code>uint8</code>, <code>uint16</code>, <code>uint32</code>, <code>uint64</code></td></tr><tr><td><code>Float</code></td><td><code>float32</code>, <code>float64</code></td></tr><tr><td><code>Nil</code></td><td><code>nil</code></td></tr><tr><td><code>Array</code></td><td><code>[]string</code>, <code>[]bool</code>, <code>[]int</code>, <code>[]int64</code>, <code>[]int32</code>, <code>[]int16</code>, <code>[]int8</code>, <code>[]uint</code>, <code>[]uint64</code>, <code>[]uint32</code>, <code>[]uint16</code>, <code>[]uint8</code>, <code>[]float64</code>, <code>[]float32</code></td></tr><tr><td><code>Object</code></td><td>any struct can be just <code>struct{}</code> or a typed struct like <code>User{}</code> with any fields or a <code>map</code> type like <code>map[string]string</code> or something else</td></tr></tbody></table><p>The biggest difference in types and type literals between Textwire and Go is that Textwire&#39;s literals have functions that you can call on them. For example, you can call a <code>split</code> function on a string literal like this: <code>{{ &quot;hello world&quot;.split(&quot; &quot;) }}</code> to get an array of strings <code>[&quot;hello&quot;, &quot;world&quot;]</code>.</p>',21)])])}const g=t(s,[["render",n]]);export{u as __pageData,g as default};
